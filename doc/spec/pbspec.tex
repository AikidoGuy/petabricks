\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{url}

\lstdefinelanguage{pbcc}{
morekeywords={transform, if, else, for, from, to, through, case, do, where, return, or,
              MatrixRegion1D, MatrixRegion2D, MatrixRegion3D, cell, region, row, col},
sensitive=true,
morecomment=[l]{\#},
morecomment=[l]{//},
morestring=[b]',
morestring=[b]",
}
\lstset{language=pbcc}
\lstset{numbers=left}
\lstset{tabsize=2}
\lstset{commentstyle=\textit}
\lstset{literate=
{REFTransform}{{\ref{sec:transform}}}{3}
{REFRule}     {{\ref{sec:rule}}}{3}
{REFBody}     {{\ref{sec:body}}}{3}
}


\begin{document}
\title{PetaBricks Language Specification}
\author{Jason Ansel}
\maketitle
\tableofcontents

\newpage
\section{Syntax}

\subsection{Minimal PetaBricks Program}

The following is an example of a (near) minimal PetaBricks program. It
copies the matrix A to the matrix B.

\begin{lstlisting}
transform Copy2D                                                 REFTransform
to B[w,h]                                                        REFTransform
from A[w,h]                                                      REFTransform
{
  to(B.cell(x,y) b)                                              REFRule
  from(A.cell(x,y) a)                                            REFRule  
  {                                          
    b=a;                                                         REFBody
  }                                         
}
\end{lstlisting}
This defines the transform Copy2D, which can be invoked as follows:

\begin{lstlisting}
MatrixRegion2D a,b;
...
Copy2D(a,b);
\end{lstlisting}

This invocation will result in the rule defined on lines~5-9, to be invoked
on every pair of elements in $a$ and $b$.

\subsection{Transform Structure}

\begin{lstlisting}
Transform Header  [REFTransform]
{
  Rule Header     [REFRule] 
  {                       
    Rule Body     [REFBody]
  }                      
  
  Rule Header     [REFRule] 
  {                       
    Rule Body     [REFBody]
  }                                         

  ...
}
\end{lstlisting}

\subsection{Transform Header}
\label{sec:transform}

\subsubsection{TRANSFORM Clause}

\begin{tabular}{| l | l |}
\hline
\bf Required & Yes                    \\
\bf Available In Version & 1.0        \\
\bf Syntax & \tt transform IDENTIFIER[\ref{IDENTIFIER}] \\
\bf Example & \tt transform Foo       \\
\hline
\end{tabular}

~

\noindent
Specifies the externally visible name of the transform.

\subsubsection{FROM Clause}

\begin{tabular}{| l | l |}
\hline
\bf Required & Yes                    \\
\bf Available In Version & 1.0        \\
\bf Syntax & \tt from MATRIXDEFLIST[\ref{MATRIXDEFLIST}] \\
\bf Example & \tt from A[w,h], B[w]     \\
\hline
\end{tabular}

~

\noindent
\noindent Defines the inputs of the transform.  The sizes of the outputs
are given as expressions containing unbound variables.  The compiler and
runtime must find a valid assignment for these unbound variables to match
the sizes of the inputs given.  The values assigned to these variables are
visible both in rule headers and in rule bodies.


\subsubsection{TO Clause}

\begin{tabular}{| l | l |}
\hline
\bf Required & Yes                    \\
\bf Available In Version & 1.0        \\
\bf Syntax & \tt to MATRIXDEFLIST[\ref{MATRIXDEFLIST}]     \\
\bf Example & \tt to C[w,h], D[w]     \\
\hline
\end{tabular}

~

\noindent Defines the outputs of the transform.  The sizes of the outputs
are given as expressions containing unbound variables that are set based on the size
of the inputs.

\subsubsection{THROUGH Clause}

\begin{tabular}{| l | l |}
\hline
\bf Required & No                          \\
\bf Available In Version & 1.0             \\
\bf Syntax & \tt through MATRIXDEFLIST[\ref{MATRIXDEFLIST}]     \\
\bf Example & \tt through E[w,h], F[w]     \\
\hline
\end{tabular}

~

\noindent Defines intermediate data used during the transform execution. This
data is temporary and neither an input nor an output.  The sizes are given
as expressions containing unbound variables that are set based on the size
of the inputs.

\subsubsection{GENERATOR Clause}

\begin{tabular}{| l | l |}
\hline
\bf Required & No \\
\bf Available In Version & 2.0            \\
\bf Syntax & \tt generator IDENTIFIERLIST[\ref{IDENTIFIERLIST}]\\
\bf Example & \tt generator Bar\\
\hline
\end{tabular}

~

\noindent Specifies the name of another transform (or list of transforms)
that should be used to generate inputs to this transform during training.
The outputs of the other transforms are paired left to right with the inputs
of this transform.  The other transforms inputs are seeded with random data
of the desired input size.

If this clause is not used, transforms will be given random data during
training.

\subsection{Rule Header}
\label{sec:rule}

\subsubsection{TO Clause}
\label{TO}
\begin{tabular}{| l | l |}
\hline
\bf Required & Yes                          \\
\bf Available In Version & 1.0             \\
\bf Syntax & \tt to( MATRIXARGLIST[\ref{MATRIXARGLIST}] ) \\
\bf Example & \tt to( A.cell(x,y) a, B.region(0, 0, x, y) b)\\
\hline
\end{tabular}

~

\noindent Specifies the outputs for the rule.

\subsubsection{FROM Clause}
\label{FROM}
\begin{tabular}{| l | l |}
\hline
\bf Required & Yes                          \\
\bf Available In Version & 1.0             \\
\bf Syntax & \tt from( MATRIXARGLIST[\ref{MATRIXARGLIST}] ) \\
\bf Example & \tt from( A.cell(x,y) a, B.region(0, 0, x, y) b)\\
\hline
\end{tabular}

~

\noindent Specifies the inputs for the rule.

\subsubsection{RECURSIVE Clause}
\begin{tabular}{| l | l |}
\hline
\bf Required & No \\
\bf Available In Version & 1.0             \\
\bf Syntax & \tt recursive( EXPRESSION[\ref{EXPRESSION}] )   \\
\bf Example & \tt recursive( n )           \\
\hline
\end{tabular}

~

\noindent Provide a hint to to autotuner that the decision to use this
rule should be based on comparing the given EXPRESSION to some constant.
Note that as of version 2.0 this language feature should no longer be needed
except in special cases.


\subsubsection{WHERE Clause}
\begin{tabular}{| l | l |}
\hline
\bf Required & No                          \\
\bf Available In Version & 2.0             \\
\bf Syntax & \tt where EXPRESSION[\ref{EXPRESSION}] \\
\bf Example & \tt where x<10               \\
\hline
\end{tabular}

~

\noindent Limits the range where this rule may be applied.

\noindent 

\subsubsection{Return-style Syntactic Sugar}

\begin{tabular}{| l | l |}
\hline
\bf Required & No \\
\bf Available In Version & 1.0        \\
\hline
\end{tabular}

~

PetaBricks allows a shorter version of rule headers that eliminates
the need for a TO clause.  It is similar to function style return syntax.
 
\begin{minipage}{\linewidth}
\begin{lstlisting}
B.cell(x,y) from(A.cell(x,y) a) {
  return a;
}
\end{lstlisting}
\end{minipage}
Is desugared to:

\begin{minipage}{\linewidth}
\begin{lstlisting}
to(B.cell(x,y) _rv) from(A.cell(x,y) a) {
  _rv=a;
  return;
}
\end{lstlisting}
\end{minipage}

\subsubsection{OR-Keyword Syntactic Sugar}

\begin{tabular}{| l | l |}
\hline
\bf Required & No \\
\bf Available In Version & 2.0        \\
\hline
\end{tabular}

~

PetaBricks provides an ``OR'' keyword to eliminate the need for redundant 
rule headers.  ``OR'' simply means repeat the last rule header. For example:
 
\begin{minipage}{\linewidth}
\begin{lstlisting}
to(B b) from(A a) {
  Foo(b,a);
} or {
  Bar(b,a);
}
\end{lstlisting}
\end{minipage}
Is desugared to:

\begin{minipage}{\linewidth}
\begin{lstlisting}
to(B b) from(A a) {
  Foo(b,a);
}
to(B b) from(A a) {
  Bar(b,a);
}
\end{lstlisting}
\end{minipage}

\subsection{Rule Body}
\label{sec:body}

Rule bodies are standard {\tt C++} code with some preprocessing performed.
All variables defined in the corresponding rule header are visible from the 
rule body.

\subsubsection{MatrixRegion Class}
Inputs an output matrix regions are of the template type {\tt
MatrixRegion<N,T>}, where $N$ is the number of dimensions and $T$ is the
element type.  The typedefs: {\tt MatrixRegion0D}, {\tt MatrixRegion1D},
{\tt MatrixRegion2D}, ... are provided to refer to output matrix regions of each
dimensionality.  Additionally the typedefs {\tt ConstMatrixRegion0D}, {\tt
ConstMatrixRegion1D}, {\tt ConstMatrixRegion2D}, ... refer to matrix
regions with read only data and are used for inputs to a rule.

This class provides references a to matrix regions and supports numerous operations
not discussed here.  The API documentation for this class can be found here:

\noindent
\url{http://kleptocracy.csail.mit.edu/pbapi/d9/db0/classhecura_1_1MatrixRegion.html}


\subsection{Definitions}
\subsubsection{MATRIXDEFLIST}
\label{MATRIXDEFLIST}
 
A comma separated list of {\tt MATRIXDEF[\ref{MATRIXDEF}]}.

\subsubsection{MATRIXDEF}
\label{MATRIXDEF}

\subsubsection{MATRIXARGLIST}
\label{MATRIXARGLIST}

A comma separated list of {\tt MATRIXARG[\ref{MATRIXARG}]}.

\subsubsection{MATRIXARG}
\label{MATRIXARG}

\subsubsection{IDENTIFIERLIST}
\label{IDENTIFIERLIST}

A comma separated list of {\tt IDENTIFIER[\ref{IDENTIFIER}]}.

\subsubsection{IDENTIFIER}
\label{IDENTIFIER}

\subsubsection{EXPRESSION}
\label{EXPRESSION}

\section{Semantics}

\subsection{Semantics for Rule Execution}

The header (defined Sec.~\ref{sec:rule}) of each rule contains a set of
free variables used to reference an explicit list input and output regions.
A rule may be {\em instantiated} by binding these free variables to values
determined by the compiler and runtime.  The compiler may bind these free
variables to any value such that:
\begin{itemize}
\item All values are non-negative integers.
\item All regions referenced exist (i.e. not out of bounds access).
\item All input regions referenced have already been computed.
\item Any WHERE clauses evaluate to true.
\end{itemize}

Once the inputs and outputs are bound to an explicit set of cells, rule
execution follows a semantics and syntax similar to that of {\tt C++} with
the additional features defined in Section~\ref{sec:body}.


\subsection{Semantics for Transform Execution}

The semantics for the execution of a transform revolve around executing
rules in parallel.  This section defines a internal state of an executing
transform and an operational semantics over this internal state for how a
running transform may progress from an initial state to a completion state.

The following definitions are required:
\begin{itemize}
\item
Let $r[\alpha]$ represent rule $r$ instantiated with free variables
bound to the set of definitions $\alpha$.
\item
Let $\mbox{depends}(r[\alpha])$ be the set of cells $r[\alpha]$
depends on (all the regions specified in the FROM[\ref{FROM}] clause when
free variables are bound using the mapping $\alpha$).
\item
Let $\mbox{provides}(r[\alpha])$ be the set of cells $r[\alpha]$
outputs on (all the regions specified in the TO[\ref{TO}] clause when free
variables are bound using the mapping $\alpha_j$).
\item Let $T$ be a static reference of a transform, consisting of a set of rules.
\item Let $R$ be a set of rule instances $r_0[\alpha_0] ... r_n[\alpha_n]$
\item Let $D$ be a set of cells.  Each element in this contains both the $x,y$ coordinate and the matrix in which the cell belongs.
\item Let $\langle T, R, D_0, D_1, D_2 \rangle$ represent the internal state for a running transform where:
  \begin{itemize}
  \item $T$ is the transform being executed.
  \item $R$ are the rules that may currently executing in parallel.  (Initially $\epsilon$)
  \item $D_0$ are cells already computed.  (Initially those defined by the FROM clause.)
  \item $D_1$ are cells that can be computed, but need not be. (Initially those defined by the THROUGH clause.) 
  \item $D_2$ are cells that must be computed.  (Initially those defined by the TO clause.)
  \end{itemize}
\end{itemize}

The following transition rules govern the progression of the internal state
of a transform during execution.  This semantics intentionally gives a lot of
freedom to the PetaBricks runtime.  Specifically,  the order of computation
is defined only as producers-before-consumers, data may be computed more
than once, and unfinished computations may be arbitrarily discarded.

~

\noindent
{\it
Transform initialization:}

~

\begin{tabular}{c}
Transform $T$ is called with inputs $D_0$ and outputs $D_2$.
\\
$D_0$ is the intermediate (THROUGH) data required by $T$.
\\\hline
$\rightarrow \langle T, \epsilon, D_0, D_1, D_2 \rangle$ 
\end{tabular}

~

\noindent
{\it
Rule execution begins:}

~

\begin{tabular}{c}
$r \in T$ \\
$\alpha$ is a legal assignment for free variables in $r$ \\
depends$(r[\alpha]) \subset D_0$  
\\\hline
$
\langle T, R, D_0, D_1, D_2 \rangle
\rightarrow
\langle T, R \cup \{r[\alpha]\}, D_0, D_1, D_2 \rangle$ 
\end{tabular}

~

\noindent
{\it
Rule execution ends:}

~

\begin{tabular}{c}
$r[\alpha]$ has finished executing
\\
$D_0' = D_0 \cup {\mbox{provides}(r[\alpha])}$
\\
$D_1 = D_1' \cup {\mbox{provides}(r[\alpha])}$
\\
$D_2 = D_2' \cup {\mbox{provides}(r[\alpha])}$
\\\hline
$
\langle T, R \cup \{r[\alpha]\}, D_0, D_1, D_2 \rangle
\rightarrow
\langle T, R, D_0', D_1', D_2' \rangle$
\end{tabular}

~

\noindent
{\it
Rule execution aborted:}

~

\begin{tabular}{c}
$
\langle T, R \cup \{r[\alpha]\}, D_0, D_1, D_2 \rangle
\rightarrow
\langle T, R, D_0, D_1, D_2 \rangle$
\end{tabular}


~

\noindent
{\it
Transform completion:}

~

\begin{tabular}{c}
$R=\epsilon$
\\
$D_2=\epsilon$
\\\hline
$
\langle T, R, D_0, D_1, D_2 \rangle
\rightarrow$
\end{tabular}

\end{document}


