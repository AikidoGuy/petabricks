#ifndef TRILSOLVE_PBCC
#define TRILSOLVE_PBCC

#include "../simple/copy.pbcc"
#include "../multiply/multiply.pbcc"

//transform RightLookingTrilsolve
//from A[n,n], IN[m,n]
//through X<n>[m,n]
//to OUT[m,n]
//{
//}

transform LeftLookingTrilsolve
from A[n,n], IN[m,n]
through INTER[m,n]
to OUT[m,n]
{
  primary to (OUT.row(0) out ) from (IN.row(0) in, A.cell(0,0) a) {
	for (int i=0; i<m; i++ ){
		out.cell(i)=in.cell(i)/a;
	}
  }

  to (INTER.region(0,j,m,j+1) inter) 
  from (OUT.region(0,0, m, j) out, A.region(0, j, j, j+1) a) 
  {
	MatrixMultiply(inter, a, out);
  }


  to (OUT.row(j) out)
  from(INTER.row(j) inter, IN.row(j) in, A.row(j) a) 
  { 
	ElementT ajj=a.cell(j);
	for (int i=0; i<m; i++ ){
                out.cell(i) = (in.cell(i)-inter.cell(i))/ajj;
        }
  }
} 

transform trilsolve
from A[n,n], IN[m,n]
to OUT[m,n]
{
  to (OUT out) from (A a, IN in) {
	LeftLookingTrilsolve(out, a, in);
  }

//  to (OUT out) from (A a, IN in) {
//	RightLookingTrilsolve(out, a, in);
//  }
}

#endif // LUDENSE_PBCC

