#ifndef LUNOPIVOT_PBCC 
#define LUNOPIVOT_PBCC

#include "../../simple/copy.pbcc"
#include "../../simple/scale.pbcc"

// Perform the rank 1 operation: A := alpha*x*y**T + A,
// where alpha is a scalar, x is an m element vector, y is an n element
// vector and A is an m by n matrix.
transform DGER
from ALPHA, X[1, m], Y[n, 1]
to A[n, m]
{
    to (A.cell(j, i) a)
    from (ALPHA alpha,
          X.cell(0, i) x,
          Y.cell(j, 0) y)
    {
        a += alpha * x * y;
    }
}

// assume OUT contains a copy of IN and do the computation in-place
transform LUnopivotInPlace
from DUMMY
to OUT[n,m]
{
    to (OUT out)
    from ()
    {
        if (m > 1 && out.cell(0, 0) != 1) {
            Scale(out.region(0, 1, 1, n), 1.0 / out.cell(0, 0));
        }
        if (m > 1 && n > 1) {
            DGER(out.region(1, 1, n, m), -1.0,
                 out.region(0, 1, 1, m),
                 out.region(1, 0, n, 1));
            LUnopivotInPlace(out.region(1, 1, n, m), 1);
        }
    }
}

/*
// element-wise version
transform LUnopivotByElement
from IN[n,n]
through A<n-1>[n,n]
to OUT[n,n]
{
    to (A<0> a0) from (IN in)
    {
        Copy2D(a0, in);
    }

    primary
    to   (A<k+1>.cell(j,i) aNext)
    from (A<k  >.cell(j,i) aPrev,
          A<k+1>.cell(k,i) left,
          A<k  >.cell(j,k) up)
    where k < i && k < j
    {
        aNext = aPrev - left * up;
    }

    to   (A<k+1>.cell(j,i) aNext)
    from (A<k  >.cell(j,i) aPrev,
          A<k  >.cell(j,k) up)
    where i > j && k == j
    {
        aNext = aPrev / up;
    }

    to   (A<k+1>.cell(i,j) aNext)
    from (A<k  >.cell(i,j) aPrev)
    {
        aNext = aPrev;
    }

    to (OUT out) from (A<n-1> an)
    {
        Copy2D(out, an);
    }
}
*/

transform LUnopivot
from IN[n,m]
to OUT[n,m]
{
    to (OUT out)
    from (IN in)
    {
#ifdef DEBUG
        fprintf(stderr, "LUnopivot called for size %d\n", n);
#endif
        Copy2D(out, in);
        LUnopivotInPlace(out, 1);
    }
}

#endif // LUNOPIVOT_PBCC
