#ifndef LUBASE_PBCC
#define LUBASE_PBCC

#include "../simple/macros.h"
#include "../simple/copy.pbcc"
#include "../simple/permute.pbcc"
#include "../simple/reduce.pbcc"
#include "../trisolve/TriSolveLL.pbcc"
#include "../multiply/multiplyAdd.pbcc"
#include "DGER.pbcc"
#include "LULAPACK.pbcc"

transform Scale2D
from ALPHA
to A[n,m]
{
    to (A.cell(j, i) a) from (ALPHA alpha)
    {
        a *= alpha;
    }
}

transform LUBaseInPlace
to A[n,m], P[m]
{
    // left looking (solve one column at a time)
    to (A a, P p) from ()
    {
        int j;
        ElementT iMax, jMax, valMax;

        for (j = 0; j < MIN(m,n); ++j) {

            // lazy update of all values in current column
            if (j > 0) {
                // update values above diagonal
                TriSolveLLInPlace(a.region(j, 0, j+1, j), 1,
                                  a.region(0, 0, j  , j));

                // update values on and below diagonal
                MatrixMultiplyAdd(a.region(j, j, j+1, m), -1.0,
                                  a.region(0, j, j  , m),
                                  a.region(j, 0, j+1, j), 1.0);
            }

            if (j == m - 1) {
                p.cell(j) = j;
            } else {
                // find the largest value in jth column
                ReduceAMax2D(jMax, iMax, valMax, a.region(j, j, j+1, m));
                iMax += j;

                // save swapped row index in p
                p.cell(j) = iMax;

                // swap pivot row into current row
                if (iMax != j) {
                    Swap2D(a.region(0, j   , n, j    + 1),
                           a.region(0, iMax, n, iMax + 1));
                }

                // scale values below diagonal
                Scale2D(a.region(j, j+1, j+1, m), 1.0 / a.cell(j, j));
            }
        }

        // solve for remainder of U matrix
        if (n > m) {
            TriSolveLLInPlace(a.region(m, 0, n, m), 1,
                              a.region(0, 0, m, m));
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }

    // right looking (update trailing matrix after each column is solved)
    to (A a, P p) from ()
    {
        int j;
        ElementT iMax, jMax, valMax;

        // for each column in square part of matrix
        for (j = 0; j < MIN(m, n); ++j) {
            if (j == m - 1) {
                p.cell(j) = j;
            } else {
                // find the largest value in jth column on/below diagonal
                ReduceAMax2D(jMax, iMax, valMax, a.region(j, j, j+1, m));
                iMax += j;

                // save swapped row index in p
                p.cell(j) = iMax;

                // swap pivot row into current row
                if (iMax != j) {
                    Swap2D(a.region(0, j   , n, j    + 1),
                           a.region(0, iMax, n, iMax + 1));
                }

                // scale current column and update trailing submatrix
                Scale2D(a.region(j, j+1, j+1, m), 1.0 / a.cell(j, j));

                if (j < n - 1) {
                    // rank 1 trailing matrix update
                    DGER(a.region(j+1, j+1, n  , m  ), -1.0,
                         a.region(j  , j+1, j+1, m  ),
                         a.region(j+1, j  , n  , j+1));
                }
            }
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }

    // right looking serial
    to (A a, P p) from ()
    {
        IndexT i, j, k, ip;
        ElementT maxVal, temp;
        for (j = 0; j < MIN(m,n); ++j) {
            // find pivot
            ip = j; maxVal = fabs(a.cell(j, j));
            for (i = j+1; i < m; ++i) {
                if (fabs(a.cell(j, i)) > maxVal) {
                    maxVal = fabs(a.cell(j, i));
                    ip = i;
                }
            }
            p.cell(j) = ip;
            // swap rows
            if (ip != j) {
                for (k = 0; k < n; ++k) {
                    temp = a.cell(k, j);
                    a.cell(k, j) = a.cell(k, ip);
                    a.cell(k, ip) = temp;
                }
            }
            // scale column below diagonal
            temp = 1.0 / a.cell(j, j);
            for (i = j+1; i < m; ++i) {
                a.cell(j, i) *= temp;
            }
            // update trailing matrix
            for (i = j+1; i < m; ++i) {
                for (k = j+1; k < n; ++k) {
                    a.cell(k, i) -= a.cell(j, i) * a.cell(k, j);
                }
            }
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }

    // left looking serial
    to (A a, P p) from ()
    {
        IndexT i, j, k, ip;
        ElementT maxVal, temp;
        for (j = 0; j < n; ++j) {
            // update values in current column
            for (i = 0; i < m; ++i) {
                for (k = 0; k < MIN(i, j); ++k) {
                    a.cell(j, i) -= a.cell(k, i) * a.cell(j, k);
                }
            }
            if (j < m) {
                // find pivot
                ip = j; maxVal = fabs(a.cell(j, j));
                for (i = j+1; i < m; ++i) {
                    if (fabs(a.cell(j, i)) > maxVal) {
                        maxVal = fabs(a.cell(j, i));
                        ip = i;
                    }
                }
                p.cell(j) = ip;
                // swap rows
                if (ip != j) {
                    for (k = 0; k < n; ++k) {
                        temp = a.cell(k, j);
                        a.cell(k, j) = a.cell(k, ip);
                        a.cell(k, ip) = temp;
                    }
                }
                // scale column below diagonal
                temp = 1.0 / a.cell(j, j);
                for (i = j+1; i < m; ++i) {
                    a.cell(j, i) *= temp;
                }
            }
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }

    // call LAPACK
    to (A a, P p) from ()
    {
        LULAPACK(a, p, a);
    }
}

transform LUBase
from IN[n,m]
to OUT[n,m], P[m]
{
   to (OUT out, P p) from (IN in)
   {
       Copy2D(out, in);
       LUBaseInPlace(out, p);
   }
}

#endif // LUBASE_PBCC
