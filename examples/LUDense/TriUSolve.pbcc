#ifndef TRIUSOLVE_PBCC
#define TRIUSOLVE_PBCC

#include "../simple/copy.pbcc"
#include "../multiply/multiply.pbcc"
#include "MatrixSubtract.pbcc"

// Solve XU = B for X, where U is upper triangular

// right looking version
transform TriUSolveBaseRL
from A[n,n], B[n,m]
to X[n,m]
{
    primary
    to   (X.cell(0, i) x)
    from (B.cell(0, i) b, A.cell(0,0) a)
    {
        x = b / a;
    }

    to   (X.region(j, 0, j+1, m) xout)
    from (X.region(0, 0, j  , m) x, A.region(j, 0, j+1, j) a,
          B.region(j, 0, j+1, m) b, A.cell(j,j) ajj)
    {
        MatrixRegion2D temp = MatrixRegion2D::allocate(1, m);
        MatrixMultiply(temp, x, a);
        MatrixSubtract(xout, b, temp, 1.0 / ajj);
    }
}

// left looking version
transform TriUSolveBaseLL
from A[n,n], B[n,m]
to X[n,m]
{
    primary
    to   (X.cell(0, i) x)
    from (B.cell(0, i) b, A.cell(0,0) a)
    {
        x = b / a;
    }

    to   (X.region(j, 0, j+1, m) xout)
    from (X.region(0, 0, j  , m) x, A.region(j, 0, j+1, j) a,
          B.region(j, 0, j+1, m) b, A.cell(j, j) ajj)
    {
        MatrixRegion2D temp = MatrixRegion2D::allocate(1, m);
        MatrixMultiply(temp, x, a);
        MatrixSubtract(xout, b, temp, 1.0 / ajj);
    }
}

transform TriUSolve
from A[n,n], B[n,m]
to X[n,m]
{
    to (X x) from (A a, B b) {
#ifdef DEBUG
        fprintf(stderr, "TriUSolve called for size (%d, %d)\n", m, n);
#endif
        TriUSolveBaseLL(x, a, b);
    }

    to (X x) from (A a, B b) {
#ifdef DEBUG
        fprintf(stderr, "TriUSolve called for size (%d, %d)\n", m, n);
#endif
        TriUSolveBaseRL(x, a, b);
    }
}

#endif // TRIUSOLVE_PBCC

