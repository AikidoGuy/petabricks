#ifndef PLUBLOCK3_PBCC
#define PLUBLOCK3_PBCC

#include "LUupper.pbcc"
#include "PLU.pbcc"
#include "../multiply/multiply.pbcc"
#include "../simple/add.pbcc"

transform SwapElements
from IN[n], P[n]
to OUT[n]
{
  to (OUT out) from (IN in, P p)
  {
        for (int j=0; j<n; j++)
        {
                out.cell(j)=in.cell(p.cell(j));
        }
  }
}

transform SwapRows
from IN[n,m], P[m]
to OUT[n,m]
{
  to (OUT out) from (IN in, P p)
  {
	for (int j=0; j<m; j++)
	{
		Copy1D(out.row(j), in.row(p.cell(j)));
	}
  }
}

transform PLUblock3
from IN[n, n], Pin[n]
through TEMP[n, n], Ptemp[n], Phalf[n-n/3]
to OUT[n, n], Pout[n]
{
  //get LU of left block by recursion
  to (TEMP.region(0,0,n/3,n) temp, Ptemp ptemp)
  from (IN.region(0,0,n/3,n) in, Pin pin)
  {
        PLUnoblock(temp,ptemp,in, pin);
  }

  //upper left block is final
  to (OUT.region(0,0,n/3,n/3) out) from (TEMP.region(0,0,n/3,n/3) temp)
  {
	Copy2D(out, temp);
  }

  //first half of Permutation vector is final
  to (Pout.region(0,n/3) pout) from (Ptemp.region(0,n/3) ptemp)
  {
	Copy1D(pout, ptemp);
  }

  //swap right block
  to (TEMP.region(n/3,0,n,n) temp)
  from (IN.region(n/3,0,n,n) in, Ptemp ptemp)
  {
        SwapRows(temp, in, ptemp);
  }

  //upper right block
  to (OUT.region(n/3,0,n,n/3) out)
  from (TEMP.region(n/3,0,n,n/3) swappedin,
	TEMP.region(0,0,n/3,n/3) leftdiag)
  {
	LUuppertrirecur(out,swappedin,leftdiag);
  }
  

  //lower right block
  to (OUT.region(n/3,n/3,n,n) out, Phalf phalf)
  from (TEMP.region(n/3,n/3,n,n) in,
        OUT.region(n/3,0,n,n/3) up,
        TEMP.region(0,n/3,n/3,n) left)
  {
	//Atemp = in - left*up (this updates the lower right block)
        MatrixRegion2D Atemp = MatrixRegion2D::allocate(n-n/3, n-n/3);
        MatrixMultiply(out,left,up);
        MatrixSub(Atemp,in,out);

	//recursion to get LU of the remaining updated block
        PLUrecur(out,phalf,Atemp);
  }

  //lower left block
  to (OUT.region(0,n/3,n/3,n) out)
  from (TEMP.region(0,n/3,n/3,n) temp,  Phalf phalf)

  {
        SwapRows(out,temp,phalf);
  }

  //last half of Permutation vector
  to (Pout.region(n/3,n) pout) from (Ptemp.region(n/3,n) ptemp, Phalf phalf)
  {
	SwapElements(pout, ptemp, phalf);
  }

}


transform PLUrecurinner
from IN[n,n], Pin[n]
to OUT[n,n], Pout[n]
{
  to (OUT out, Pout pout) from (IN in, Pin pin)
  {
	if (n < 3) {
		PLUnoblock(out,pout,in,pin);
	}
	else {
		PLUblock3(out, pout, in, pin);
	}
  }


}

main transform PLUrecur
from IN[n,n]
through Pinitial[n]
to OUT[n,n], Pout[n]
{  
  Pinitial.cell(j) from () { return j;}

  to (OUT out, Pout pout) from (IN in, Pinitial pin)
  {
	PLUrecurinner(out,pout,in,pin);
  }
}

#endif // PLUBLOCK3_PBCC
