#ifndef TRIUSOLVE_PBCC
#define TRIUSOLVE_PBCC

#include "../simple/copy.pbcc"
#include "../multiply/multiply.pbcc"


// Solve XU=B for X, i.e. X = B*inv(U), where U is the upper triangular part of A

//transform RightLookingTriusolve
//from A[n,n], IN[n,m]
//through X<n>[n,m]
//to OUT[n,m]
//{
//}

transform LeftLookingTriusolve
from A[n,n], B[n,m]
through INTER[n,m]
to X[n,m]
{

/*
  primary X.cell(i,n-1) from (B.cell(i,n-1) b, A.cell(n-1,n-1) a) {
	return b/a;
  }

  primary INTER.cell(i,n-1) from (B.cell(i,n-1) b) {
        return b;
  }
*/

  primary to (X.col(0) x ) from (B.col(0) b, A.cell(0,0) a) {
        for (int i=0; i<m; i++ ){
                x.cell(i)=b.cell(i)/a;
        }
  }


  primary to (INTER.col(0) inter) from (B.col(0) b) {
        Copy1D(inter, b);
  }

  to (INTER.region(j,0,j+1,m) inter)
  from (X.region(0,0,j , m) x, A.region(j, 0, j+1, j) a)
  {
      MatrixMultiply(inter, x, a);
  }

/*
  X.cell(i,j) from (INTER.cell(i,j) inter, B.cell(i,j) b, A.cell(j,j) ajj) {
	return inter;
  }
*/

  to (X.col(j) x)
  from(INTER.col(j) inter, B.col(j) b, A.cell(j,j) ajj)
  {
        for (int i=0; i<m; i++ ){
                x.cell(i) = (b.cell(i)-inter.cell(i))/ajj;
        }
  }


} 

transform triusolve
from A[n,n], B[n,m]
to X[n,m]
{
  to (X out) from (A a, B in) {
	LeftLookingTriusolve(out, a, in);
  }

//  to (X out) from (A a, B in) {
//	RightLookingTriusolve(out, a, in);
//  }
}

#endif // TRIUSOLVE_PBCC

