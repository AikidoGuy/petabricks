#ifndef MATRIXAPPROX_PBCC
#define MATRIXAPPROX_PBCC

//#ifndef k
//#define k 4
//#endif

#include "../multiply/multiply.pbcc"
#include "../simple/copy.pbcc"
#include "../eigenproblem/EigSym.pbcc"
#include "../simple/transpose.pbcc"

transform MatrixApprox
//param k  //input param: number of singular values used k<=n
from IN[n,n], k
through Lambda[2*n], X[2*n,2*n], U[n,n], VT[n,n], H[2*n,2*n], TEMP[n,n]
to OUT[n,n], NORM
{


	to (H.region(n,0,2*n,n) h) from (IN a) {
		Transpose(h, a);
	}
	to (H.region(0,n,n,2*n) h )from (IN a){
		Copy2D(h, a);
	}
	secondary H.cell(i,j) from() {
		return 0;
	}

	to (Lambda lam, X x) from (H h){ 
		EigSym(lam, x, h);
	}

//	Sigma.cell(i) from (Lambda.cell(i) lam) {
//		return -lam;
//	}

//      U.cell(i,j) from (X.cell(i,j+n) x){
//              return -sqrt(2)*x;
//      }

	//combine sigma(k) * U(k)
	U.cell(i,j) from (X.cell(i,j+n) x, Lambda.cell(i) lam){
		return lam*sqrt(2)*x;
	}

	//V tranposed
	VT.cell(j,i) from (X.cell(i,j) x){
		return sqrt(2)*x;	
	}
		


	to (OUT out, TEMP temp) from (U u, VT vt){
		int i;
		MatrixMultiply(out, u.region(0,0,1,n), vt.region(0,0,n,1) );
		for (i=1; i<k; i++) { //forenough?
			//MatrixAdd(out, out, MatrixMultiply(u.region(i,0,i+1,n), vt.region(0,i,n,i+1)) );
			MatrixMultiply(temp, u.region(i,0,i+1,n), vt.region(0,i,n,i+1));
			MatrixAdd(out, out, temp);
		}
	} 

	//accuracy measure
	NORM  from(IN in, OUT out) 
	{
		int i;
		int j;
		ElementT sum=0;
		for (i=0; i<n; i++) {
			for (j=0; j<n; j++) {
				sum+=fabs(in.cell(i,j)-out.cell(i,j));
			}
		}
		sum=sum/n/n/50;
		if (sum > 1) return 0;
		return 1-sum;
	}
			
}


#endif // MATRIXAPPROX_PBCC
