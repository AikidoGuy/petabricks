#include "../utilities.pbcc"

#ifndef WAY
#define WAY 32
#endif

#define CAT(a,b) _CAT(a,b)
#define _CAT(a,b) a ## b

#ifndef SORTSUBARRAY
#define SORTSUBARRAY CAT(MergesortSubArray, WAY)
#endif

transform CAT(Merge, WAY)
from IN[n]
to OUT[n]
{
  to (OUT out) from (IN in)
  {
    int i, j, ptr[WAY], minLoc;
    double min;
    for (i = 0; i < WAY; i++) {
      ptr[i] = n * i / WAY;
    }
    for (i = 0; i < n; i++) {
      min = HUGE_VAL;
      minLoc = -1;
      for (j = 0; j < WAY; j++) {
        if (ptr[j] < n * (j + 1) / WAY && in.cell(ptr[j]) < min) {
          min = in.cell(ptr[j]);
          minLoc = j;
        }
      }
      if (minLoc == -1) {
        printf("error\n");
        exit(-1);
      }
      out.cell(i) = min;
      ptr[minLoc]++;
    }
  }
}

transform CAT(MergesortSubArray, WAY)
from IN[n], Pos
to OUT[n], TEMP[n]
{
  recursive to(OUT out, TEMP temp) from (IN in, Pos p)
  {
    int i;

    for (i = 0; i < WAY; i++) {
      if (n * (i + 1) / WAY - n * i / WAY > 1) {
        SPAWN(SORTSUBARRAY, out .region(n * i / WAY, n * (i + 1) / WAY),
                            temp.region(n * i / WAY, n * (i + 1) / WAY),
                            in  .region(n * i / WAY, n * (i + 1) / WAY), p);
      }
    }

    SYNC();
    SPAWN(Copy1D, temp, out);
    SYNC();
    SPAWN(CAT(Merge, WAY), out, temp);
  }
}

transform CAT(Mergesort, WAY)
from IN[n]
to OUT[n]
{
  to(OUT out) from (IN in)
  {
    InlineCopy1D(out, in);
    MatrixRegion1D temp = MatrixRegion1D::allocate(n);
    CAT(MergesortSubArray,WAY)(out, temp, in, 64);
  }
}


