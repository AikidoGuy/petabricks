#include "../utilities.pbcc"

transform Merge
from IN[n]
to OUT[n]
{
  to (OUT out) from (IN in)
  {
    int middle = n / 2, ptr1 = 0, ptr2 = middle;
    for (int i = 0; i < n; i++) {
      if (ptr2 == n || ptr1 < middle && in.cell(ptr1) < in.cell(ptr2)) {
//        printf("1");
        out.cell(i) = in.cell(ptr1++);
      } else {
//        printf("2");
        out.cell(i) = in.cell(ptr2++);
      }
    }
//    printf("\n");
  }
}

transform MergesortSubArray
from IN[n], Left, Right
to OUT[n], TEMP[n]
{
  to(OUT out, TEMP temp) from (IN in, Left left, Right right)
  {
    int middle = (left + right + 1) / 2;

    if (middle - left > 1)
      MergesortSubArray(out, temp, in, left, middle - 1);
    if (right - middle > 0)
      MergesortSubArray(out, temp, in, middle, right);
    
    Copy1D(temp.region((int) left, (int) right + 1), out.region((int) left, (int) right + 1));
/*
    printf("Merge being called on (%d, %d)\n", (int) left, (int) right);
    printf("Before merge: (%d", (int) out.cell(0));
    for (int i = 1; i < n; i++) {
      printf(", %d", (int) out.cell(i));
    }
    printf(")\n");
*/
    Merge(out.region((int) left, (int) right + 1), temp.region((int) left, (int) right + 1));
/*
    printf("After merge: (%d", (int) out.cell(0));
    for (int i = 1; i < n; i++) {
      printf(", %d", (int) out.cell(i));
    }
    printf(")\n");
*/
  }
}

transform Mergesort
from IN[n]
to OUT[n]
{
  to(OUT out) from (IN in)
  {
    Copy1D(out, in);
    MatrixRegion1D temp = MatrixRegion1D::allocate(n);
    MergesortSubArray(out, temp, in, 0, n - 1);
  }
}
