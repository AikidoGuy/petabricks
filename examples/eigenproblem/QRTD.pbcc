#ifndef QRTD_PBCC
#define QRTD_PBCC

%{

extern "C" void dsteqr_(char *compz, int *n, double *D, double *E, double *Z, int *ldz, double *work, int *info);
extern "C" void ssteqr_(char *compz, int *n, float *D, float *E, float *Z, int *ldz, float *work, int *info);

void steqr_wrap(char *compz, int *n, float *D, float *E, float *Z, int *ldz, float *work, int *info) {
  ssteqr_(compz, n, D, E, Z, ldz, work, info);
}

void steqr_wrap(char *compz, int *n, double *D, double *E, double *Z, int *ldz, double *work, int *info) {
  dsteqr_(compz, n, D, E, Z, ldz, work, info);
}
%}

#include "../simple/copy.pbcc"
#include "../simple/transpose.pbcc"

// Find eigenvalues and eigenvectors of tridiagonal matrix by LAPACK QR iteration routines
// note output is Transposed because of row-major and column major difference for LAPACK and PetaBricks
transform QRTDsub
from Subdiag[n-1]
to Eigenvalue[n], Eigenvector[n,n]
{

  to (Eigenvalue Eig, Eigenvector Vec) from (Subdiag Ein)
  {


    char compz='I';
    int size=n, lwork=2*n-2, info=0, nsquared=n*n;

    // allocate and initialize matrices
    ElementT *Z = Vec.base();
    ElementT *D = Eig.base();
    ElementT *E = Ein.storage()->data();
    ElementT *work = new ElementT[1];

    if (lwork > 1) { work = new ElementT[lwork];}
    steqr_wrap(&compz, &size, D, E, Z, &size, work, &info);

    delete [] work;
  }

}

transform QRTD
from Diag[n], Subdiag[n-1]
//through Eigvectemp[n,n]
to Eigenvalue[n], Eigenvector[n,n]
{

  to (Eigenvalue Eig, Eigenvector Vec) from (Diag Din, Subdiag Ein)
  {

	Copy1D(Eig, Din);
	QRTDsub(Eig, Vec, Ein);
	//Transpose(Vec,Vtemp);
  }

}

#endif // QRTD_PBCC
