#ifndef TRAINMGV2D_PBCC
#define TRAINMGV2D_PBCC
#include "BS2D.pbcc"
#include "ComputeError.pbcc"
#include "mgv2D.pbcc"

transform trainmgv2D
from X[n,n], B[n,n]
through zeros[(n+1)/2,(n+1)/2]
to Y[n,n]
{
  zeros.cell(i,j) from() {
    return 0;
  }

  recursive
  to (Y y) from (X x, B b, zeros z)
  {
    double error, estimateError, newError, oldError, change;
    double prec[5] = {1e-1, 1e-3, 1e-5, 1e-7, 1e-9};
    int level = (int) log2(n-1), iterations = 0,
        result[5] = {0, 0, 0, 0, 0}, ptr = 0;
    MatrixRegion2D r;

    printf("Accuracy levels: (%g, %g, %g, %g, %g)\n",
        prec[0], prec[1], prec[2], prec[3], prec[4]);

    printf("Training run for level %d\n", level);
    MatrixRegion2D actual;
    if (level < 6) {
      actual = BS2D(x, b);
    } else {
      actual = mgv2D(x, b, 30);
    }
    error = (double) ComputeError(x, actual);
    printf("initial error = %g\n", error);

    Copy2D(y, x);

    newError = error;
    oldError = error;
    change = 0;
    while (newError / error > prec[4] && change < 1) {
      iterations++;
      mgv2D(y, y, b, 1);
      newError = ComputeError(y, actual);
      change = newError / oldError;
      oldError = newError;
      printf("%d: error = %g, ratio = %g\n",
          iterations, newError, newError / error);
      while (ptr < 5 && newError / error <= prec[ptr]) {
        result[ptr++] = iterations;
      }
      if (change >= 1) {
        break;
      }
    }
    printf("Level %d: {%d, %d, %d, %d, %d}\n", level, 
        result[0], result[1], result[2], result[3], result[4], result[5]);
  }
}

#endif // TRAINMGV2D_PBCC

