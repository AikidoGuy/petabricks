  // precision LOCALPREC
  recursive(n)
  to (Y y) from(X x, B b, zeros z) {
    int level = (int) log2(n - 1);
    RUNPRINTF("prec%d recursive case (call to prec%d) called for level %d (%d iterations)\n", CURPREC, LOCALPREC, level, (int) CAT(CAT(CAT(prec, LOCALPREC), Iters_Prec), CURPREC)[level]);
    if (level <= 1) {
      RUNPRINTF("  aborting\n");
      PetabricksRuntime::abort();
    } else {
      int i;
      int level = (int) log2(n-1);
      if ((int) CAT(CAT(CAT(prec, LOCALPREC), Iters_Prec), CURPREC)[level] == -1) {
        RUNPRINTF("  aborting\n");
        PetabricksRuntime::abort();
      }
      MatrixRegion2D t1 = MatrixRegion2D::allocate(n, n);
      MatrixRegion2D t2 = MatrixRegion2D::allocate(n, n);
      MatrixRegion2D r1 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);
      MatrixRegion2D r2 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);

      Copy2D(y, x);
      for (i = 0; i < CAT(CAT(CAT(prec, LOCALPREC), Iters_Prec), CURPREC)[level]; i++) {
        SOR2D(t1, y, b, -2, 1);   // t1 gets relaxed guess
        Residual2D(t2, t1, b);    // t2 gets new residual
        Restrict2Dnew(r1, t2);    // r1 gets restricted residual
        CAT(Poisson2D_Inner_Prec, LOCALPREC)(r2, z, r1); // r2 gets coarse update
        Interpolate2Dnew(t2, r2); // t2 gets interpolated update
        MatrixAdd(t2, t2, t1);    // t2 gets updated guess
        SOR2D(y, t2, b, -2, 1);   //  y gets relaxed guess
      }
    }
  }

