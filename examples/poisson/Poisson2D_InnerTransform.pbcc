%{

JTUNABLEARRAY(CAT(  SORIters_Prec, CURPREC), 30, 1);
JTUNABLEARRAY(CAT(prec1Iters_Prec, CURPREC), 30, 1);
JTUNABLEARRAY(CAT(prec2Iters_Prec, CURPREC), 30, 1);
JTUNABLEARRAY(CAT(prec3Iters_Prec, CURPREC), 30, 1);
JTUNABLEARRAY(CAT(prec4Iters_Prec, CURPREC), 30, 1);
JTUNABLEARRAY(CAT(prec5Iters_Prec, CURPREC), 30, 1);

%}

transform CAT(Poisson2D_Inner_Prec,CURPREC)
from X[n,n], B[n,n]
to  Y[n,n]
through zeros[(n+1)/2,(n+1)/2]
{
  //base case: directly solve with BS
  to(Y y) from(X x, B b) {
    int level = (int) log2(n-1);
    if (level > 8) {
      printf("  aborting\n");
      HecuraRuntime::abort();
    }
    printf("prec%d BS case called for level %d\n", CURPREC, level);
    BS2D(y, x, b);
  }

  //base case: solve iteratively with SOR
  to(Y y) from(X x, B b) {
    int level = (int) log2(n-1);
    if ((int) CAT(SORIters_Prec, CURPREC)[level] == -1) {
      printf("  aborting\n");
      HecuraRuntime::abort();
    }
    printf("prec%d SOR case called for level %d (%d iterations)\n", CURPREC,
           level, (int) CAT(SORIters_Prec, CURPREC)[level]);
    SOR2D(y, x, b, -1, (int) CAT(  SORIters_Prec, CURPREC)[level]);
  }

  //solve recursively on coarser grids, with zero initial guess
  //then map the coarse solution back to the fine grid by Interpolation
  zeros.cell(i,j) from() {
    return 0;
  }

  //recursive cases

#define LOCALPREC 1
#include "Poisson2D_RunLoop.pbcc"
#undef LOCALPREC
#define LOCALPREC 2
#include "Poisson2D_RunLoop.pbcc"
#undef LOCALPREC
#define LOCALPREC 3
#include "Poisson2D_RunLoop.pbcc"
#undef LOCALPREC
#define LOCALPREC 4
#include "Poisson2D_RunLoop.pbcc"
#undef LOCALPREC
#define LOCALPREC 5
#include "Poisson2D_RunLoop.pbcc"
#undef LOCALPREC

}

