//Multigrid V-cycle 2D
//assume dimension n = 2^k + 1

%{

JTUNABLE(numIterations, 1);

%}

#include "../add.pbcc"
#include "Interpolate2Dnew.pbcc"
#include "Restrict2Dnew.pbcc"
#include "Residual2D.pbcc"
#include "SOR2D.pbcc"
#include "BS2D.pbcc"

transform mgv2D 
from X[n,n], B[n,n]
to  Y[n,n]
through zeros[(n+1)/2,(n+1)/2]
{
    //base case: solve iteratively with SOR
    to(Y y) from(X x, B b) {
        printf("SOR base case called for n = %d\n", n);
        int iter[20] = {  1,   5,   7,  13,  26,
                         52, 100, 100, 100, 100,
                        100, 100, 100, 100, 100,
                        100, 100, 100, 100, 100};  // values for greater than 6 not computed yet
        printf("SOR base case called for n = %d (%d iterations)\n", n, iter[(int) log2(n-1) - 1]);
        SOR2D(y, x, b, -1, iter[(int) log2(n-1) - 1]);
    }

    //base case: directly solve with BS
    to(Y y) from(X x, B b) {
        printf(" BS base case called for n = %d\n", n);
        BS2D(y, x, b);
    }

    //solve recursively on coarser grids, with zero initial guess
    //then map the coarse solution back to the fine grid by Interpolation
    zeros.cell(i,j) from() {
        return 0;
    }

    //recursive case
    recursive(n / 2)
    to (Y y) from(X x, B b, zeros z) {
        printf("recursive case called for n = %d\n", n);
        JASSERT(floor(log2(n-1)) == log2(n-1));
        MatrixRegion2D t, r;
        t = SOR2D(x, b, -2, 1);
        r = Restrict2Dnew(Residual2D(t,b));
        r = mgv2D(z,r);
        t = MatrixAdd(Interpolate2Dnew(r), t);
        SOR2D(y, t, b, -2, 1);
    }
}

