//Multigrid V-cycle 2D
//assume dimension n = 2^k + 1

#include "../simple/add.pbcc"
#include "Interpolate2Dnew.pbcc"
#include "Restrict2Dnew.pbcc"
#include "Poisson2DResidual.pbcc"
#include "Poisson2DSOR.pbcc"
#include "Poisson2DBS.pbcc"
#include "ComputeError.pbcc"

#ifndef RUNPRINTF
#define RUNPRINTF //printf
#endif

main transform Poisson2DSolve
from X[n,n], B[n,n]
to  Y[n,n]
{
  to (Y y) from (X x, B b)
  {
    JASSERT(floor(log2(n-1)) == log2(n-1))(n)(floor(log2(n-1)))(log2(n-1)).Text("input must be 2^k+1");
    JASSERT(n > 1)(n).Text("input must be size larger than 1");

    Poisson2DSolveInner(y, x, b);
  }
}

transform Poisson2DSolveInner
from X[n,n], B[n,n]
to  Y[n,n]
through zeros[(n+1)/2,(n+1)/2]
accuracy_bins 0.1, 0.001, 0.00001, 0.0000001, 0.000000001
accuracy_variable numIterations
accuracy_metric ComputeError
{
  //base case: directly solve with BS
  to(Y y) from(X x, B b) {
    int level = (int) log2(n-1);
    if (level > 8) {
      RUNPRINTF("  ERROR: cannot call BS case for level > 8\n");
      PetabricksRuntime::abort();
    }
    RUNPRINTF("BS case called for level %d, acc %d\n", level, accLvl);
    Poisson2DBS(y, x, b);
  }

  //base case: solve iteratively with SOR
  to(Y y) from(X x, B b) {
    int level = (int) log2(n-1);
    RUNPRINTF("SOR case called for level %d, acc %d (%d iterations)\n", level, accLvl, numIterations);
    Poisson2DSOR(y, x, b, -1, numIterations);
  }

  //solve recursively on coarser grids, with zero initial guess
  //then map the coarse solution back to the fine grid by Interpolation
  zeros.cell(i,j) from() {
    return 0;
  }

  //recursive case: call itself using multigrid
  recursive(n)
  to (Y y) from(X x, B b, zeros z) {
    int level = (int) log2(n - 1);
    RUNPRINTF("recursive case called for level %d, acc %d (%d iterations)\n", level, accLvl, numIterations);
    if (level <= 1) {
      RUNPRINTF("  ERROR: cannot call recursive case for level < 2\n");
      PetabricksRuntime::abort();
    } else {
      int i;
      int level = (int) log2(n-1);
      MatrixRegion2D t1 = MatrixRegion2D::allocate(n, n);
      MatrixRegion2D t2 = MatrixRegion2D::allocate(n, n);
      MatrixRegion2D r1 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);
      MatrixRegion2D r2 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);

      Copy2D(y, x);
      // forenough
      for (i = 0; i < numIterations; i++) {
        Poisson2DSOR(t1, y, b, -2, 1);  // t1 gets relaxed guess
        Poisson2DResidual(t2, t1, b);   // t2 gets new residual
        Restrict2Dnew(r1, t2);          // r1 gets restricted residual
        Poisson2DSolveInner(r2, z, r1); // r2 gets coarse update
        Interpolate2Dnew(t2, r2);       // t2 gets interpolated update
        MatrixAdd(t2, t2, t1);          // t2 gets updated guess
        Poisson2DSOR(y, t2, b, -2, 1);  //  y gets relaxed guess
      }
    }
  }
}
