//Multigrid V-cycle 2D
//assume dimension n = 2^k + 1

%{
  JTUNABLE(prec_case, 5);
  JTUNABLEARRAY(levelTrained, 30, 0);
%}

#include "../simple/add.pbcc"
#include "Interpolate2Dnew.pbcc"
#include "Restrict2Dnew.pbcc"
#include "Residual2D.pbcc"
#include "SOR2D.pbcc"
#include "BS2D.pbcc"
#include "mgv2D.pbcc"
#include "ComputeError.pbcc"

#define CAT( a, b) _CAT(a,b)
#define _CAT( a, b) __CAT(a ## b)
#define __CAT(ab) ab

#ifndef TRAINPRINTF
#define TRAINPRINTF printf
#endif
#ifndef RUNPRINTF
#define RUNPRINTF //printf
#endif

#define POISSON_PRECISION_1 0.1
#define POISSON_PRECISION_2 0.001
#define POISSON_PRECISION_3 0.00001
#define POISSON_PRECISION_4 0.0000001
#define POISSON_PRECISION_5 0.000000001

#define CURPREC 1
#include "Poisson2D_InnerTransform.pbcc"
#undef CURPREC
#define CURPREC 2
#include "Poisson2D_InnerTransform.pbcc"
#undef CURPREC
#define CURPREC 3
#include "Poisson2D_InnerTransform.pbcc"
#undef CURPREC
#define CURPREC 4
#include "Poisson2D_InnerTransform.pbcc"
#undef CURPREC
#define CURPREC 5
#include "Poisson2D_InnerTransform.pbcc"
#undef CURPREC

transform Poisson2D
from X[n,n], B[n,n]
to  Y[n,n]
through zeros[(n+1)/2,(n+1)/2]
{
  zeros.cell(i,j) from() {
    return 0;
  }

  to (Y y) from (X x, B b, zeros z)
  {
    double error;
    double newError;
    double oldError;
    double change;
    int level = (int) log2(n-1);
    MatrixRegion2D t1 = MatrixRegion2D::allocate(n, n);
    MatrixRegion2D t2 = MatrixRegion2D::allocate(n, n);
    MatrixRegion2D r1 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);
    MatrixRegion2D r2 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);

    JASSERT(floor(log2(n-1)) == log2(n-1))(n)(floor(log2(n-1)))(log2(n-1)).Text("input must be 2^k+1");
    JASSERT(n > 1)(n).Text("input must be larger than 1");

    if (PetabricksRuntime::isTrainingRun()) {
      if (levelTrained[level] == 0) {
        TRAINPRINTF("Training run for level %d\n", level);
        MatrixRegion2D actual = MatrixRegion2D::allocate(n,n);
        if (level < 4) {
          BS2D(actual, x, b);
        } else {
          mgv2D(actual, x, b, 15);
        }
        ComputeError(error, x, actual);
        TRAINPRINTF("initial error = %g\n", error);

#define CURPREC 1
#include "Poisson2D_TrainingLoop.pbcc"
#undef CURPREC
#define CURPREC 2
#include "Poisson2D_TrainingLoop.pbcc"
#undef CURPREC
#define CURPREC 3
#include "Poisson2D_TrainingLoop.pbcc"
#undef CURPREC
#define CURPREC 4
#include "Poisson2D_TrainingLoop.pbcc"
#undef CURPREC
#define CURPREC 5
#include "Poisson2D_TrainingLoop.pbcc"
#undef CURPREC

        levelTrained[level].setValue(1);
      }
    } else {
      RUNPRINTF("Timing run for level %d, precision %d\n", level, (int) prec_case);
      if (prec_case == 1) {
          Poisson2D_Inner_Prec1(y, x, b);
      } else if (prec_case == 2) {
          Poisson2D_Inner_Prec2(y, x, b);
      } else if (prec_case == 3) {
          Poisson2D_Inner_Prec3(y, x, b);
      } else if (prec_case == 4) {
          Poisson2D_Inner_Prec4(y, x, b);
      } else if (prec_case == 5) {
          Poisson2D_Inner_Prec5(y, x, b);
      }
    }
  }
}

