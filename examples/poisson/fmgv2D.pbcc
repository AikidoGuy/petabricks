//Full Multigrid V-cycle 2D
//assume dimension n = 2^k + 1

#include "mgv2D.pbcc"

transform Restrict2Dfmg
//return Restricted RHS vector for coarser grid
from X[n,n]
to  Y[(n+1)/2,(n+1)/2]  //C will truncate
{
  //interior components
  Y.cell(i,j)
  from( X.cell(2*i-1,2*j-1) xnw,
	X.cell(2*i,2*j-1) xn,
	X.cell(2*i+1,2*j-1) xne,
	X.cell(2*i-1,2*j) xw,
	X.cell(2*i,2*j) xc,
	X.cell(2*i+1,2*j) xe,
	X.cell(2*i-1,2*j+1) xsw,
	X.cell(2*i,2*j+1) xs,
	X.cell(2*i+1,2*j+1) xse)
 // X.region(2*i-1,2*j-1,2*i+1,2*j+1) x) 
  {
    return xc/4+(xn+xe+xw+xs)/8+(xne+xnw+xsw+xse)/16;
  }

  //zero boundary conditions
  secondary Y.cell(i,j) from() {return 0;}

}



transform fmgv2Dbase
//base case for fmgv2D
from R[n,n]
to Y[n,n]
//n should equal 3 whenever this is called
//R has zero boundary conditions
{
   Y.cell(i,j) from(R.cell(i,j) r){
	return r/4;
   }
}

transform fmgv2Drecur
from R[n,n], weight, it1, it2, itb, k
to OUT[n,n]
{
   to (OUT y) from(R r, weight w, it1 s1, it2 s2, itb sb, k kk)
   {
     if (kk == 1) {
       fmgv2Dbase(y, r);
     } else {
       MatrixRegion0D krec = MatrixRegion0D::allocate();
       krec.cell() = kk - 1;
       mgv2D(y, Interpolate2Dnew( fmgv2Drecur(Restrict2Dfmg(r),w,s1,s2,sb,krec) ),r ,w,s1,s2,sb);
     }
   }
}

transform fmgv2D
from X[n,n], B[n,n], weight, it1, it2, itb, k
//input: X = initial guess
//       B = right handside
//	 weight = weight factor for SOR
//       it1,it2 = number of steps of SOR/iteative methods before and after recursive calls to mgv1D
//	 itb = number of iterative steps for base case (used in mgv2D)
//	     k = log(n-1), base2
to Y[n,n]
{
	to (Y y) from(X x, B b, weight w, it1 s1, it2 s2, itb sb, k kk) {
		MatrixAdd(y, x, fmgv2Drecur( Residual2D(x, b), w, s1, s2, sb, kk));
	}
}