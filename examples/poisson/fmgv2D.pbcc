#ifndef FMGV2D_PBCC
#define FMGV2D_PBCC

//Multigrid V-cycle 2D
//assume dimension n = 2^k + 1
#include "../add.pbcc"
#include "../utilities.pbcc"
#include "Interpolate2Dnew.pbcc"
#include "Restrict2Dnew.pbcc"
#include "Residual2D.pbcc"
#include "SOR2D.pbcc"
#include "mgv2D.pbcc"

%{
void printMatrix(ConstMatrixRegion2D A)
{
  for (int i = 0; i < A.size(1); i++) {
    for (int j = 0; j < A.size(0); j++) {
      printf("%g ", A.cell(j, i));
    }
    printf("\n");
  }
}
%}

transform fmgv2D_inner
from X[n,n], B[n,n]
through zeros[(n+1)/2,(n+1)/2]
to  Y[n,n]
{
    //solve recursively on coarser grids, with zero initial guess
    //then map the coarse solution back to the fine grid by Interpolation
    zeros.cell(i,j) from() {
        return 0;
    }

    //recursive case
    recursive(n / 2)
    to (Y y) from(X x, B b, zeros z) {
        JASSERT(floor(log2(n-1)) == log2(n-1))(n).Text("input must be 2^k+1");
        if (n == 3) {
//          printf("base case called for n = 3\n");
          Copy2D(y, x);
          y.cell(1, 1) = (x.cell(1, 0) + x.cell(0, 1) + x.cell(1, 2) + x.cell(2, 1) + b.cell(1, 1)) / 4;
        } else {
//          printf("recursive case called for n = %d\n", n);
          MatrixRegion2D r;
          r = Restrict2Dnew(Residual2D(x,b));
          r = fmgv2D_inner(z,r);
          MatrixAdd(y, Interpolate2Dnew(r), x);
          mgv2D(y, y, b, 1);
        }
    }
}

transform fmgv2D
from X[n,n], B[n,n], numIterations
to Y[n,n]
{
  recursive
  to (Y y) from (X x, B b, numIterations num)
  {
    if (num > 0) {
      SPAWN(fmgv2D_inner, y, x, b);
    } else {
      SPAWN(Copy2D, y, x);
    }
    SYNC();
    if (num > 1)
      SPAWN(mgv2D, y, y, b, num - 1);
  }
}

#endif // FMGV2D_PBCC

