#ifndef KMEANS_PBCC
#define KMEANS_PBCC

#ifndef k
#define k 5

#include "../simple/copy.pbcc"
#include "newclusterlocations.pbcc"
#include "assignclusters.pbcc"
#include "distance.pbcc"
#include "../simple/rollingsum.pbcc"


transform GetD
from X[m,2], C[n,2]
to D[m,n]
{
        to (D.cell(i,j) d) from (X.column(i) x, C.column(j) c)
        {
                Distance(d,x,c);
        }
}

transform GetMin
from X[m,n]
to MinX[m]
{
        MinX.cell(i) from(X.column(i) x){
                int j;
                ElementT minvalue=x.cell(0);
                for (j=1; j<n; j++) {
                        if (x.cell(j) < minvalue) {
                                minvalue=x.cell(j);
                        }
                }
                return minvalue*minvalue;
        }
}

transform centerplus
from X[n,2]
through D[n,k], DMIN[n], DSQ[n], Xtemp[n,2]
to C[k,2]
{
  to (C c, D d, DMIN dmin, DSQ dsq, Xtemp x) from (X xin){

        int l;
        int m;
        ElementT rvalue;

        srand(time(0));

        Copy2D(x,xin);
        Copy1D(c.column(0), x.column(0));

        for (m=1; m<k; m++) {

                //get distance of all remanining x with current cluster centers
                GetD(d.region(m,0,n,m), x.region(m,0,n,2), c.region(0,0,m,2));

                //find minimum of each column, squared and compute cumulative sum
                GetMin(dmin.region(m,n), d.region(m,0,n,m));
                RollingSum(dsq.region(m,n),dmin.region(m,n));

                //pick center with probability proportional to dmin (D(x)^2)
                rvalue= (   (double)rand() / ((double)(RAND_MAX)+(double)(1)) );
                rvalue*=dsq.cell(n-1);
                for (l=m; l<n; l++){
                        if (rvalue<=dsq.cell(l)){
                                Copy1D(c.column(m),x.column(l)); //new center picked
                                if (l!=m) { Copy1D(x.column(l), x.column(m)); }//swap columns for next iteration
                                break;
                        }
                }
        }
   }

}

			
transform kmeans
from X[n,2]    // X - x,y coordinates of n points,  k - number of clusters
through CFLAG, Ctemp[k,2]
to C[k,2], A[n]// , WCSS   // C - centroids, A - cluster assignment, WCSS - within-cluster sum of squares  (error measures)
{

  //Assign initial cluster centers randomly
  to (Ctemp ctemp) from (X x)
  {
	InlineCopy2D(ctemp,x.region(0,0,k,2));
  }

  //or Assign initial cluster centers using k-means++ algorithm
  to (Ctemp ctemp) from (X x)
  {
	centerplus(ctemp, x);
  }

  //iteratively find local optimum
  to (C c, A a, CFLAG change) from (X x, Ctemp ctemp)
  {
    change=1;
    InlineCopy2D(c,ctemp);    

    while (change > 0)  {
	AssignClusters(a,change,x,c,a);
	if (change > 0) { 
		NewClusterLocations(c, x, a);
	}
    }

  }

//  //accuracy measure
//  WCSS from(X x, C c, A a)
//  {
//	ElementT dis;
//	ElementT sum;
//	int i;
//	sum=0;
//	for (i=0; i< n; i++) {
//		Distance(dis, x.column(i), c.column(a.cell(i)));
//		sum+=dis;
//        }
//	return sum/n;
//  }

}


#endif // KMEANS_PBCC
