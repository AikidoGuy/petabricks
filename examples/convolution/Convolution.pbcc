#ifndef CONVOLUTION_PBCC
#define CONVOLUTION_PBCC

#include "ConvolutionFFT.pbcc"
#define WAYS 2
#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#define MIN(x, y) ((x) <= (y) ? (x) : (y))

transform ConvolutionRegular
from A[n], B[m]
to C[n+m-1]
{
  to (C c) from (A a, B b)
  {
    int i, j;
    for (i = 0; i < m + n - 1; i++) {
      c.cell(i) = 0;
    }
    for (i = 0; i < n; i++) {
      for (j = 0; j < m; j++) {
        c.cell(i+j) += a.cell(i) * b.cell(j);
      }
    }
  }
}

// assumes first argument is longer
// TODO: T should be smaller: ((waySize + m - 1) x WAYS),
//       where waySize = ceiling(n / WAYS)
transform ConvolutionRecursive
from A[n], B[m]
//through T[((n + WAYS - 1) / WAYS) + m - 1, WAYS]
through T[n + m - 1, WAYS]
to C[n+m-1]
{
  to (T.row(i) t) from (A a, B b)
  {
    int waySize = (n + WAYS - 1) / WAYS;
    int aStart = i * waySize;
    int aEnd = MIN((i + 1) * waySize, n);
    int aSegLen = aEnd - aStart;
    Convolution(t.region(0, aSegLen + m - 1),
                a.region(aStart, aEnd),
                b);
    int j;
//  printf("(%g", t.cell(0));
//  for (j = 1; j < aSegLen + m - 1; j++) {
//    printf(", %g", t.cell(j));
//  }
//  printf(")\n");
  }

  to (C.cell(i) c) from (T t)
  {
    int j, waySize = (n + WAYS - 1) / WAYS;
    c = 0;
    for (j = MAX(0, (i - (m - 1)) / waySize);
         j < MIN(WAYS, i / waySize + 1);
         j++) {
      c += t.cell(i - j * waySize, j);
    }
  }
}

transform Convolution
from A[n], B[m]
to C[n+m-1]
{
  recursive(n+m-1)
  to (C c) from (A a, B b)
  {
    ConvolutionRegular(c, a, b);
  }

  recursive(n+m-1)
  to (C c) from (A a, B b)
  {
    ConvolutionFFT(c, a, b);
  }

  recursive(n+m-1)
  to (C c) from (A a, B b)
  {
    if (a.count() <= 1 && b.count() <= 1) {
      ConvolutionRegular(c, a, b);
    } else {
      if (a.count() >= b.count())
      {
        ConvolutionRecursive(c, a, b);
      } else {
        ConvolutionRecursive(c, b, a);
      }
    }
  }
}

#endif // CONVOLUTION_PBCC
