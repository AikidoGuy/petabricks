  //base case: solve iteratively with SOR
  recursive
  to(Y y) from(X x, B b, zeros z) {
    int level = (int) log2(n-1);
    RUNPRINTF("full est %d prec %d SOR case called for level %d (%d iterations)\n", ESTPREC, CURPREC, level, (int) CAT(SORIters_Prec, CURPREC)[level]);
    if (level <= 1 ||
        (int) CAT(CAT(CAT(full_SORIters_Est, ESTPREC), _Prec), CURPREC)[level] == -1) {
      RUNPRINTF("  aborting\n");
      HecuraRuntime::abort();
    }
    MatrixRegion2D t, r;

    // compute estimate
    Copy2D(y, x);
#if ESTPREC > 0
    r = Restrict2Dnew(Residual2D(y, b));
    r = CAT(FullPoisson2D_Inner_Prec, ESTPREC)(z, r);
    MatrixAdd(y, Interpolate2Dnew(r), y);
#endif

    // do iteration
    SOR2D(y, y, b, -1, (int) CAT(CAT(CAT(full_SORIters_Est, ESTPREC), _Prec), CURPREC)[level]);
  }

#define LOCALPREC 1
#include "FullPoisson2D_RunRecursive.pbcc"
#undef LOCALPREC
#define LOCALPREC 2
#include "FullPoisson2D_RunRecursive.pbcc"
#undef LOCALPREC
#define LOCALPREC 3
#include "FullPoisson2D_RunRecursive.pbcc"
#undef LOCALPREC
#define LOCALPREC 4
#include "FullPoisson2D_RunRecursive.pbcc"
#undef LOCALPREC
#define LOCALPREC 5
#include "FullPoisson2D_RunRecursive.pbcc"
#undef LOCALPREC

