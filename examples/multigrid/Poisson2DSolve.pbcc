//Multigrid V-cycle 2D
//assume dimension n = 2^k + 1

#include "../simple/add.pbcc"
#include "Interpolate2Dnew.pbcc"
#include "Restrict2Dnew.pbcc"
#include "Poisson2DResidual.pbcc"
#include "Poisson2DSOR.pbcc"
#include "Poisson2DBS.pbcc"
#include "Poisson2DAccuracyMetric.pbcc"

transform recursiveMGV
from X[n,n], B[n,n], Z[n,n], Bin, Iters
to Y[n,n]
{
    to (Y y) from (X x, B b, Z z, Bin bin, Iters iters)
    {
        int level = (int) log2(n - 1);

#ifdef DEBUG
        printf("recursive case called for level %d, acc %d (%d iterations)\n", level, bin, iters);
#endif

        if (level <= 1) {

#ifdef DEBUG
            printf("  ERROR: cannot call recursive case for level < 2\n");
#endif

            PetabricksRuntime::abort();

        } else {

            int i;
            MatrixRegion2D t1 = MatrixRegion2D::allocate(n, n);
            MatrixRegion2D t2 = MatrixRegion2D::allocate(n, n);
            MatrixRegion2D r1 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);
            MatrixRegion2D r2 = MatrixRegion2D::allocate((n+1)/2, (n+1)/2);

            // copy input to output
            Copy2D(y, x);

            // iterate the recursive call for iters iterations
            for (i = 0; i < iters; i++) {
                Poisson2DSOR(t1, y, b, -2, 1);  // t1 gets relaxed guess
                Poisson2DResidual(t2, t1, b);   // t2 gets new residual
                Restrict2Dnew(r1, t2);          // r1 gets restricted residual
                Poisson2DSolve(bin, r2, z, r1); // r2 gets coarse update
                Interpolate2Dnew(t2, r2);       // t2 gets interpolated update
                MatrixAdd(t2, t2, t1);          // t2 gets updated guess
                Poisson2DSOR(y, t2, b, -2, 1);  //  y gets relaxed guess
            }
        }
    }
}

transform Poisson2DSolve
from X[n,n], B[n,n]
to  Y[n,n]
through zeros[(n+1)/2,(n+1)/2]
accuracy_bins 0.1, 0.001, 0.00001, 0.0000001, 0.000000001
accuracy_variable numIterations
accuracy_metric Poisson2DAccuracyMetric
{
    //base case: directly solve with BS
    to(Y y) from(X x, B b) {
        int level = (int) log2(n-1);
        if (level > 8) {
#ifdef DEBUG
            printf("  ERROR: cannot call BS case for level > 8\n");
#endif
            PetabricksRuntime::abort();
        }
#ifdef DEBUG
        printf("BS case called for level %d, acc %d\n", level, accLvl);
#endif
        Poisson2DBS(y, x, b);
    }

    //base case: solve iteratively with SOR
    to(Y y) from(X x, B b) {
        int level = (int) log2(n-1);
#ifdef DEBUG
        printf("SOR case called for level %d, acc %d (%d iterations)\n", level, accLvl, numIterations);
#endif
        Poisson2DSOR(y, x, b, -1, numIterations);
    }

    //solve recursively on coarser grids, with zero initial guess
    //then map the coarse solution back to the fine grid by Interpolation

    to (zeros.cell(i,j) z) from () {
        z = 0;
    }

    //recursive case with accuracy bin 1
    recursive(n)
    to (Y y) from(X x, B b, zeros z) {
        recursiveMGV(y, x, b, z, 1, numIterations);
    }

    //recursive case with accuracy bin 2
    recursive(n)
    to (Y y) from(X x, B b, zeros z) {
        recursiveMGV(y, x, b, z, 2, numIterations);
    }

    //recursive case with accuracy bin 3
    recursive(n)
    to (Y y) from(X x, B b, zeros z) {
        recursiveMGV(y, x, b, z, 3, numIterations);
    }

    //recursive case with accuracy bin 4
    recursive(n)
    to (Y y) from(X x, B b, zeros z) {
        recursiveMGV(y, x, b, z, 4, numIterations);
    }

    //recursive case with accuracy bin 5
    recursive(n)
    to (Y y) from(X x, B b, zeros z) {
        recursiveMGV(y, x, b, z, 5, numIterations);
    }
}
