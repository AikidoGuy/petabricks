#ifndef POISSON2DJACOBI_PBCC
#define POISSON2DJACOBI_PBCC

#include "../simple/copy.pbcc"
#include "Generators.pbcc"

// Note: this transform assumes IN and OUT point to different memory locations.
// In place (in memory) update is not supported.
transform Poisson2DJacobiIterate
from IN[n,n], B[n,n]
to OUT[n,n]
{
  primary
  OUT.cell(i,j) from(IN.cell(i-1, j  ) no,
                     IN.cell(i+1, j  ) so,
                     IN.cell(i  , j-1) we,
                     IN.cell(i  , j+1) ea,
                     B.cell(i,j) b)
  {
    return (no+so+we+ea+b) / 4.0;
  }

  secondary
  OUT.cell(i,j) from (IN.cell(i, j) x)
  {
    return x;
  }
}

// Wrapper around Poisson2DJacobi to handle arbitrary number of iterations.
// Note: IN and OUT may point to the same memory location, so a temporary
// array is utilized.
transform Poisson2DJacobi
from IN[n,n], B[n,n], numIterations
to OUT[n,n]
{
  to (OUT out) from (IN in, B b, numIterations _numIters)
  {
    int numIters = (int) _numIters;

    JASSERT(numIters >= 1)(numIters).Text("number of iterations must be positive");

    MatrixRegion2D temp = MatrixRegion2D::allocate(n, n);

    // compute first iteration
    Poisson2DJacobiIterate(temp, in, b);
    numIters--;

    // compute iterations until 0 or 1 remain
    while (numIters >= 2) {
      Poisson2DJacobiIterate(out, temp, b);
      Poisson2DJacobiIterate(temp, out, b);
      numIters -= 2;
    }

    if (numIters == 1) {
      Poisson2DJacobiIterate(out, temp, b);
    } else {
      Copy2D(out, temp);
    }
  }
}

#endif // POISSON2DJACOBI_PBCC
