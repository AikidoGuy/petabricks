#ifndef POISSON2DJACOBI_PBCC
#define POISSON2DJACOBI_PBCC

#include "Generators.pbcc"

#define NUM_ITERATIONS 1

transform Poisson2DJacobi_inner
from IN[n,n], B[n,n]
through S<0 .. NUM_ITERATIONS>[n,n]
to OUT[n,n]
{
  //normal case
  priority(0) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j-1) we,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (no+so+we+ea+b) / 4.0;
  }

  //edge cases
  priority(1) S<p>.cell(i,j) from(S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j-1) we,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (so+we+ea+b) / 4.0;
  }

  priority(1) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i  , j-1) we,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (no+we+ea+b) / 4.0;
  }

  priority(1) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (no+so+ea+b) / 4.0;
  }

  priority(1) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j-1) we,
                                  B.cell(i,j) b)
  {
    return (no+so+we+b) / 4.0;
  }

  //corner case
  priority(2) S<p>.cell(i,j) from(S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (so+ea+b) / 4.0;
  }

  priority(2) S<p>.cell(i,j) from(S<p-1>.cell(i+1, j  ) so,
                                  S<p-1>.cell(i  , j-1) we,
                                  B.cell(i,j) b)
  {
    return (so+we+b) / 4.0;
  }

  priority(2) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i  , j+1) ea,
                                  B.cell(i,j) b)
  {
    return (no+ea+b) / 4.0;
  }

  priority(2) S<p>.cell(i,j) from(S<p-1>.cell(i-1, j  ) no,
                                  S<p-1>.cell(i  , j-1) we,
                                  B.cell(i,j) b)
  {
    return (no+we+b) / 4.0;
  }

  //initialize and finalize
  S<0>.cell(i,j) from(IN.cell(i,j) x) {
    return x;
  }

  OUT.cell(i,j) from(S<NUM_ITERATIONS>.cell(i,j) x) {
    return x;
  }
}

transform Poisson2DJacobiInterior
from IN[n,n], B[n,n], numIterations
to OUT[n,n]
{
  to(OUT o) from(IN in, B b, numIterations k)
  {
    Poisson2DJacobi_inner(o, in, b);
    for (int i = 1; i < k; i++) {
      Poisson2DJacobi_inner(o, o, b);
    }
  }
}

transform Poisson2DJacobi
from IN[n,n], B[n,n], numIterations
to OUT[n,n]
through BTEMP[n-2,n-2]
generator Poisson2DJacobiGenerator
{
  BTEMP.cell(i,j) from(B.cell(i + 1, j + 1) b,
                       IN.cell(i, j + 1) no,
                       IN.cell(i + 2, j + 1) so,
                       IN.cell(i + 1, j) we,
                       IN.cell(i + 1, j + 2) ea)
  {
    double result = b;
    if (i == 0) result += no;
    if (i == n - 3) result += so;
    if (j == 0) result += we;
    if (j == n - 3) result += ea;
    return result;
  }

  primary to (OUT.region(1,1,n-1,n-1) o) from (IN.region(1,1,n-1,n-1) in,
                                               BTEMP b,
                                               numIterations num)
  {
    if (n == 3) {
      o.cell(0, 0) = b.cell(0, 0) / 4;
    } else {
      Poisson2DJacobiInterior(o, in, b, num);
    }
  }

  secondary OUT.cell(i,j) from (IN.cell(i,j) x)
  {
    return x;
  }
}

#endif // POISSON2DJACOBI_PBCC
