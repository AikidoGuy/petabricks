#ifndef NWKDELM_PBCC
#define NWKDELM_PBCC

#include "utils.pbcc"
#include "nwkde.pbcc"

#define DEBUG
//#define WORKAROUND // workaround for generator having specific sizes

transform NWKDELM
#ifdef WORKAROUND
from TRAINDATA[4,n], WRAPFLAGS[4], KERNELWIDTHS[4],
     TRAININDICES[n-2], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,n],
     TESTINDICES[n-2], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[n-2]
through SQDIFFS[8,n-2,n-2], WEIGHTS[n-2,n-2], PARTIALS[n-2,n-2], INPUTSCHECKED
#else
from TRAINDATA[m,n], WRAPFLAGS[m], KERNELWIDTHS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through WEIGHTS[l,q], PARTIALS[l,q], INPUTSCHECKED
#endif
generator NWKDEGenerator
//optimize KERNELWIDTHS[m]
{
    INPUTSCHECKED
    from (TRAININDICES trainIndices,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTINDICES testIndices,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
#ifdef DEBUG
        double min, max, min2, max2;

#ifdef WORKAROUND
        int m = 4, m2 = 4, n2 = 10;
#endif

        findMinAndMax(&min, &max, trainVarIndex);
        printf("trainVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m) {
            printf("trainVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        printf("outputVarIndex: %g\n", outputVarIndex);
        if (outputVarIndex < 0 || outputVarIndex > m) {
            printf("outputVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testVarIndex);
        printf("testVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m2) {
            printf("testVarIndex out of bounds: (%d, %d)\n", 0, m2);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, trainIndices);
        findMinAndMax(&min2, &max2, trainTimeOffset);
        printf("trainIndices + trainTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n) {
            printf("trainIndices + trainTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        printf("trainIndices + outputTimeOffset range: (%g, %g)\n",
               min + outputTimeOffset, max + outputTimeOffset);
        if (min + outputTimeOffset < 0 || max + outputTimeOffset > n) {
            printf("trainIndices + outputTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testIndices);
        findMinAndMax(&min2, &max2, testTimeOffset);
        printf("testIndices + testTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n2) {
            printf("testIndices + testTimeOffset out of bounds: (%d, %d)\n",
                   0, n2);
            PetabricksRuntime::abort();
        }
#endif // DEBUG

        return 0;
    }

    WEIGHTS.cell(j,k)
    from (TRAINDATA trainData,
          WRAPFLAGS wrapFlags,
          KERNELWIDTHS kernelWidths,
          TRAININDICES.cell(j) trainIndex,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTDATA testData,
          TESTINDICES.cell(k) testIndex,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset)
    {
        double sum = 0;

        for (int i = 0; i < trainVarIndex.count(); ++i) {

            int wrapFlag = (int) wrapFlags.cell((int) trainVarIndex.cell(i));
            double kernelWidth = kernelWidths.cell((int) trainVarIndex.cell(i));

            int trainTimeIndex = (int) trainIndex + (int) trainTimeOffset.cell(i);
            int  testTimeIndex = (int)  testIndex + (int)  testTimeOffset.cell(i);

            double trainPoint = trainData.cell((int) trainVarIndex.cell(i), trainTimeIndex);
            double  testPoint =  testData.cell((int)  testVarIndex.cell(i),  testTimeIndex);

#ifdef DEBUG
            if (trainPoint == -1) {
                trainPoint = NAN;
            }
            if (testPoint == -1) {
                testPoint == NAN;
            }
#endif // DEBUG

            double diff = trainPoint - testPoint;

            if (wrapFlag) {

                // wrap relative difference into [-180,180]
                // do most of the arithmetic in integers for speed
                // P360 and M360 indicate "plus 360" and "minus 360"

                // add 360 *before* cast to round towards -INF instead of towards 0
                int diffIntP360 = (int) (diff + 360);

                // add 180 to ensure modulo result is positive
                int diffIntWrapP360 = ((diffIntP360 + 180) % 360) + 180;

                double diffFracM360 = diff - diffIntP360;
                diff = diffIntWrapP360 + diffFracM360;
            }

            // normalize according to kernel width
            diff /= kernelWidth;

            // return squared difference
            sum += diff * diff;
        }

        return exp(-((double) sum));
    }

    to (PARTIALS.cell(j,k) partial)
    from (TRAINDATA trainData,
          TRAININDICES.cell(j) trainIndex,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset,
          WEIGHTS.cell(j,k) weight)
    {
        int timeIndex = (int) trainIndex + (int) outputTimeOffset;
        partial = trainData.cell((int) outputVarIndex, timeIndex);
        partial *= weight;
    }

    to (RESULT.cell(k) result)
    from (PARTIALS.row(k) partials,
          WEIGHTS.row(k) weights,
          INPUTSCHECKED checkDummy)
    {
        double totalWeight;
        ReduceAdd(result, partials);
        ReduceAdd(totalWeight, weights);
        result /= totalWeight;
#ifdef DEBUG
        printf("Output %d = %g\n", k, result);
#endif // DEBUG
    }
}

#endif // NWKDELM_PBCC

