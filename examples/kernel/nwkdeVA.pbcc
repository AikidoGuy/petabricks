#ifndef NWKDEVA_PBCC
#define NWKDEVA_PBCC

#include "nwkde.pbcc"

/* This function returns the -log10 of the MSE produced by NWKDEVA.
 * 
 * WARNING: This metric assumes that the true value the regression
 * aims to produce is located in the TESTDATA at the location pointed
 * to by OUTPUTVARINDEX and OUTPUTTIMEOFFSET, even though strictly
 * speaking, those values are meant only as indexes into TRAINDATA,
 * not TESTDATA.
 *
 * If this condition is not met, use a different metric transform to
 * measure output accuracy.
 */
transform NWKDEMetric
#ifdef WORKAROUND
from RESULT[q], TRAINDATA[4,8750], WRAPFLAGS[4],
     TRAININDICES[l], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,8750],
     TESTINDICES[q], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET, TRAINMASKWIDTH
to METRIC
#else
from RESULT[q], TRAINDATA[m,n], WRAPFLAGS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET, TRAINMASKWIDTH
to METRIC
#endif
{
    to (METRIC metric)
    from (RESULT result,
          TESTDATA testData,
          TESTINDICES testIndices,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
        double a, b, diff, sum = 0;
        int outputTimeIndex;

        for (int i = 0; i < q; ++i) {
            outputTimeIndex = (int) testIndices.cell(i) + (int) outputTimeOffset;
            a = result.cell(i);
            b = testData.cell((int) outputVarIndex, outputTimeIndex);
            diff = a - b;
            fprintf(stderr, "%g = (%g - %g)\n", diff, a, b);
            sum += diff * diff;
        }

        sum /= q;

        if (sum == 0) {
            sum = std::numeric_limits<double>::epsilon();
        }
        metric = -log10(sum);        
    }
}

transform NWKDEVA
#ifdef WORKAROUND
from TRAINDATA[4,8750], WRAPFLAGS[4],
     TRAININDICES[l], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,8750],
     TESTINDICES[q], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET, TRAINMASKWIDTH
to RESULT[q]
tunable float sizespecific array(4) initial(1) KERNELWIDTHS
#else
from TRAINDATA[m,n], WRAPFLAGS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET, TRAINMASKWIDTH
to RESULT[q]
//tunable float sizespecific array(m) initial(1) KERNELWIDTHS
#endif
generator NWKDEGenerator2
accuracy_metric NWKDEMetric
{
    to (RESULT result)
    from (TRAINDATA        trainData,
          WRAPFLAGS        wrapFlags,
          TRAININDICES     trainIndices,
          TRAINVARINDEX    trainVarIndex,
          TRAINTIMEOFFSET  trainTimeOffset,
          TESTDATA         testData,
          TESTINDICES      testIndices,
          TESTVARINDEX     testVarIndex,
          TESTTIMEOFFSET   testTimeOffset,
          OUTPUTVARINDEX   outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset,
          TRAINMASKWIDTH   trainMaskWidth)
    {
        // copy kernel widths into matrix region
#ifdef WORKAROUND
        int m = 4;
#endif
        MatrixRegion1D kernelWidths = MatrixRegion1D::allocate(m);
        for (int i = 0; i < m; ++i) {
            kernelWidths.cell(i) = KERNELWIDTHS[i];
        }

        NWKDE(result, trainData, wrapFlags, kernelWidths,
              trainIndices, trainVarIndex, trainTimeOffset,
              testData, testIndices,
              testVarIndex, testTimeOffset,
              outputVarIndex, outputTimeOffset, trainMaskWidth);
    }
}

#endif // NWKDEVA_PBCC
