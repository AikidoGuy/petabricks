#ifndef NWKDE_PBCC
#define NWKDE_PBCC

#include "utils.pbcc"
#define DEBUG
#define WORKAROUND // workaround for generator having specific sizes

transform NWKDEGenerator
from IN[n]
to   TRAINDATA[4,8750], WRAPFLAGS[4], KERNELWIDTHS[4],
     TRAININDICES[n], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,8750],
     TESTINDICES[n], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
{
    to (TRAINDATA trainData,
        WRAPFLAGS wrapFlags,
        KERNELWIDTHS kernelWidths,
        TRAININDICES trainIndices,
        TRAINVARINDEX trainVarIndex,
        TRAINTIMEOFFSET trainTimeOffset,
        TESTDATA testData,
        TESTINDICES testIndices,
        TESTVARINDEX testVarIndex,
        TESTTIMEOFFSET testTimeOffset,
        OUTPUTVARINDEX outputVarIndex,
        OUTPUTTIMEOFFSET outputTimeOffset)
    from (IN in)
    {
        MatrixRegion2D a;
        MatrixRegion1D b;

        a = MatrixIO("test/trainData.pba", "r").read2D();
        Copy2D(trainData, a);
        b = MatrixIO("test/wrapFlags.pba", "r").read1D();
        Copy1D(wrapFlags, b.region(0,4));
        b = MatrixIO("test/kernelWidths.pba", "r").read1D();
        Copy1D(kernelWidths, b.region(0,4));
        b = MatrixIO("test/trainIndices.pba", "r").read1D();
        Copy1D(trainIndices, b.region(0,n));
        b = MatrixIO("test/trainVarIndex.pba", "r").read1D();
        Copy1D(trainVarIndex, b.region(0,8));
        b = MatrixIO("test/trainTimeOffset.pba", "r").read1D();
        Copy1D(trainTimeOffset, b.region(0,8));

        a = MatrixIO("test/testData.pba", "r").read2D();
        Copy2D(testData, a);
        b = MatrixIO("test/testIndices.pba", "r").read1D();
        Copy1D(testIndices, b.region(0,n));
        b = MatrixIO("test/testVarIndex.pba", "r").read1D();
        Copy1D(testVarIndex, b.region(0,8));
        b = MatrixIO("test/testTimeOffset.pba", "r").read1D();
        Copy1D(testTimeOffset, b.region(0,8));

        outputVarIndex = MatrixIO("test/outputVarIndex.pba", "r").read0D();
        outputTimeOffset = MatrixIO("test/outputTimeOffset.pba", "r").read0D();
    }
}

transform NWKDECheckInputs
from TRAINDATA[m,n], TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2], TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to INPUTSCHECKED
{
    INPUTSCHECKED
    from (TRAININDICES trainIndices,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTINDICES testIndices,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
        double min, max, min2, max2;

        findMinAndMax(&min, &max, trainVarIndex);
        printf("trainVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m) {
            printf("trainVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        printf("outputVarIndex: %g\n", outputVarIndex);
        if (outputVarIndex < 0 || outputVarIndex > m) {
            printf("outputVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testVarIndex);
        printf("testVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m2) {
            printf("testVarIndex out of bounds: (%d, %d)\n", 0, m2);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, trainIndices);
        findMinAndMax(&min2, &max2, trainTimeOffset);
        printf("trainIndices + trainTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n) {
            printf("trainIndices + trainTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        printf("trainIndices + outputTimeOffset range: (%g, %g)\n",
               min + outputTimeOffset, max + outputTimeOffset);
        if (min + outputTimeOffset < 0 || max + outputTimeOffset > n) {
            printf("trainIndices + outputTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testIndices);
        findMinAndMax(&min2, &max2, testTimeOffset);
        printf("testIndices + testTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n2) {
            printf("testIndices + testTimeOffset out of bounds: (%d, %d)\n",
                   0, n2);
            PetabricksRuntime::abort();
        }
    }
}

/*  TRAINDATA - block of data: n time slices, m variables per time slice
    WRAPFLAGS - indicates whether TRAINDATA column corresponds to a wind
                direction \in [0, 360]
    KERNELWIDTHS - width of the kernel function to use for a data column
    TRAININDICES - l time indices into TRAINDATA to use for training
    TESTPOINTS - q data points (each of p-dim) to do the regression
    OUTPUTVARINDEX - which variable in TRAINDATA for output
    OUTPUTTIMEOFFSET - time offset from trainIndex in TRAINDATA for output

    For each dimension of TESTPOINTS:
      VARINDEX - which variable in TRAINDATA
      TIMEOFFSET - time offset from the trainIndex in TRAINDATA

    SQDIFFS - squared differences between each test point and the train data
              for each training index and for each point dimension
    WEIGHTS - weights computed with Gaussian kernel function for each
              train-test point pair
    PARTIALS - weighted output partial sums
*/

transform NWKDE
#ifdef WORKAROUND
from TRAINDATA[4,8750], WRAPFLAGS[4], KERNELWIDTHS[4],
     TRAININDICES[l], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,8750],
     TESTINDICES[q], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through SQDIFFS[8,l,q], WEIGHTS[l,q], PARTIALS[l,q], INPUTSCHECKED
#else
from TRAINDATA[m,n], WRAPFLAGS[m], KERNELWIDTHS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through SQDIFFS[p,l,q], WEIGHTS[l,q], PARTIALS[l,q], INPUTSCHECKED
#endif
generator NWKDEGenerator
//optimize KERNELWIDTHS[m]
{
    INPUTSCHECKED
    from (TRAINDATA        trainData,
          TRAININDICES     trainIndices,
          TRAINVARINDEX    trainVarIndex,
          TRAINTIMEOFFSET  trainTimeOffset,
          TESTDATA         testData,
          TESTINDICES      testIndices,
          TESTVARINDEX     testVarIndex,
          TESTTIMEOFFSET   testTimeOffset,
          OUTPUTVARINDEX   outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
        double ret;
#ifdef DEBUG
        NWKDECheckInputs(ret, trainData, trainIndices,
                         trainVarIndex, trainTimeOffset,
                         testData, testIndices,
                         testVarIndex, testTimeOffset,
                         outputVarIndex, outputTimeOffset);
#endif
        return 0;
    }

    SQDIFFS.cell(i,j,k)
    from (TRAINDATA trainData,
          WRAPFLAGS wrapFlags,
          KERNELWIDTHS kernelWidths,
          TRAININDICES.cell(j) trainIndex,
          TRAINVARINDEX.cell(i) trainVarIndex,
          TRAINTIMEOFFSET.cell(i) trainTimeOffset,
          TESTDATA testData,
          TESTINDICES.cell(k) testIndex,
          TESTVARINDEX.cell(i) testVarIndex,
          TESTTIMEOFFSET.cell(i) testTimeOffset)
    {
        int wrapFlag = (int) wrapFlags.cell((int) trainVarIndex);
        double kernelWidth = kernelWidths.cell((int) trainVarIndex);

        int trainTimeIndex = (int) trainIndex + (int) trainTimeOffset;
        int  testTimeIndex = (int)  testIndex + (int)  testTimeOffset;

        double trainPoint = trainData.cell((int) trainVarIndex, trainTimeIndex);
        double  testPoint =  testData.cell((int)  testVarIndex,  testTimeIndex);

        double diff = trainPoint - testPoint;

        if (wrapFlag) {
            
            // wrap relative difference into [-180,180]
            // do most of the arithmetic in integers for speed
            // P360 and M360 indicate "plus 360" and "minus 360"

            // add 360 *before* cast to round towards -INF instead of towards 0
            int diffIntP360 = (int) (diff + 360);

            // add 180 to ensure modulo result is positive
            int diffIntWrapP360 = ((diffIntP360 + 180) % 360) + 180;

            double diffFracM360 = diff - diffIntP360;
            diff = diffIntWrapP360 + diffFracM360;
        }

        // normalize according to kernel width
        diff /= kernelWidth;

        // return squared difference
        return diff * diff;
    }

    to (WEIGHTS.cell(j,k) weight)
#ifdef WORKAROUND
    from (SQDIFFS.region(0, j,   k,
                         8 ,j+1, k+1) sqDiffs)
#else
    from (SQDIFFS.region(0, j,   k,
                         p ,j+1, k+1) sqDiffs)
#endif
    {
        ReduceAdd(weight, sqDiffs.slice(2,0).slice(1,0));
        weight = exp(-((double) weight));
    }

    to (PARTIALS.cell(j,k) partial)
    from (TRAINDATA trainData,
          TRAININDICES.cell(j) trainIndex,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset,
          WEIGHTS.cell(j,k) weight)
    {
        int timeIndex = (int) trainIndex + (int) outputTimeOffset;
        partial = trainData.cell((int) outputVarIndex, timeIndex);
        partial *= weight;
    }

    to (RESULT.cell(k) result)
    from (PARTIALS.row(k) partials,
          WEIGHTS.row(k) weights,
          INPUTSCHECKED checkDummy)
    {
        double totalWeight;
        ReduceAdd(result, partials);
        ReduceAdd(totalWeight, weights);
        result /= totalWeight;
#ifdef DEBUG
        printf("Output %d = %g\n", k, result);
#endif // DEBUG
    }
}

#endif // NWKDE_PBCC

