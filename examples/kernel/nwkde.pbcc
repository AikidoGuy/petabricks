#ifndef NWKDE_PBCC
#define NWKDE_PBCC

#include "utils.pbcc"

/*  TRAINDATA - block of data: n time slices, m variables per time slice
    WRAPFLAGS - indicates whether TRAINDATA column corresponds to a wind
                direction \in [0, 360]
    KERNELWIDTHS - width of the kernel function to use for a data column
    TRAININDICES - l time indices into TRAINDATA to use for training
    TESTPOINTS - q data points (each of p-dim) to do the regression
    OUTPUTVARINDEX - which variable in TRAINDATA for output
    OUTPUTTIMEOFFSET - time offset from trainIndex in TRAINDATA for output

    For each dimension of TESTPOINTS:
      VARINDEX - which variable in TRAINDATA
      TIMEOFFSET - time offset from the trainIndex in TRAINDATA

    SQDIFFS - squared differences between each test point and the train data
              for each training index and for each point dimension
    WEIGHTS - weights computed with Gaussian kernel function for each
              train-test point pair
    PARTIALS - weighted output partial sums
*/

transform NWKDE
from TRAINDATA[m,n], WRAPFLAGS[m], KERNELWIDTHS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through SQDIFFS[p,l,q], WEIGHTS[l,q], PARTIALS[l,q]
//optimize KERNELWIDTHS[m]
{
    SQDIFFS.cell(i,j,k)
    from (TRAINDATA trainData,
          WRAPFLAGS wrapFlags,
          KERNELWIDTHS kernelWidths,
          TRAININDICES.cell(j) trainIndex,
          TRAINVARINDEX.cell(i) trainVarIndex,
          TRAINTIMEOFFSET.cell(i) trainTimeOffset,
          TESTDATA testData,
          TESTINDICES.cell(k) testIndex,
          TESTVARINDEX.cell(i) testVarIndex,
          TESTTIMEOFFSET.cell(i) testTimeOffset)
    {
        int wrapFlag = (int) wrapFlags.cell((int) trainVarIndex);
        double kernelWidth = kernelWidths.cell((int) trainVarIndex);

        int trainTimeIndex = (int) trainIndex + (int) trainTimeOffset;
        int  testTimeIndex = (int)  testIndex + (int)  testTimeOffset;

        double trainPoint = trainData.cell((int) trainVarIndex, trainTimeIndex);
        double  testPoint =  testData.cell((int)  testVarIndex,  testTimeIndex);

        double diff = trainPoint - testPoint;

        if (wrapFlag) {
            
            // wrap relative difference into [-180,180]
            // do most of the arithmetic in integers for speed
            // P360 and M360 indicate "plus 360" and "minus 360"

            // add 360 *before* cast to round towards -INF instead of towards 0
            int diffIntP360 = (int) (diff + 360);

            // add 180 to ensure modulo result is positive
            int diffIntWrapP360 = ((diffIntP360 + 180) % 360) + 180;

            double diffFracM360 = diff - diffIntP360;
            diff = diffIntWrapP360 + diffFracM360;
        }

        // normalize according to kernel width
        diff /= kernelWidth;

        // return squared difference
        return diff * diff;
    }

    to (WEIGHTS.cell(j,k) weight)
    from (SQDIFFS.region(0, j,   k, 
                         p ,j+1, k+1) sqDiffs)
    {
        ReduceAdd(weight, sqDiffs.slice(2,0).slice(1,0));
        weight = exp(-((double) weight));
    }

    to (PARTIALS.cell(j,k) partial)
    from (TRAINDATA trainData,
          TRAININDICES.cell(j) trainIndex,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset,
          WEIGHTS.cell(j,k) weight)
    {
        int timeIndex = (int) trainIndex + (int) outputTimeOffset;
        partial = trainData.cell((int) outputVarIndex, timeIndex);
        partial *= weight;
    }

    to (RESULT.cell(k) result)
    from (PARTIALS.row(k) partials,
          WEIGHTS.row(k) weights)
    {
        double totalWeight;
        ReduceAdd(result, partials);
        ReduceAdd(totalWeight, weights);
        result /= totalWeight;
    }
}

#endif // NWKDE_PBCC

