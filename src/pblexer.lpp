%option caseless
%option stack
%option yylineno
%option nostdinit
%option noyywrap
%option nounput
%option prefix="pb"
%option outfile="lex.yy.c"

%{
#include "transform.h"
#include "rule.h"
#include "formula.h"
#include "matrixdef.h"
#include "jassert.h"
#include "jconvert.h"
#include "pbparser.h"
#include "codegenerator.h"
#include <stdio.h>
#include <string>
#include <sstream>

using namespace std;

#define NUM_STR_BUFFERS 64

static std::stringstream theParseLog;

static const char* circularStringCache(const char* str){
  static std::string strbuffers[NUM_STR_BUFFERS];
  static int n = 0;
  return (strbuffers[n++ % NUM_STR_BUFFERS]=str).c_str();
}

static void recordLitCode(){
  std::string str = theParseLog.str().c_str();
  theParseLog.str("");
  hecura::CodeGenerator::theFilePrefix() << std::string(str.begin(), str.end()-2);
}

#define YY_USER_ACTION pblval.str=circularStringCache(yytext); theParseLog<<yytext;
#define YY_DECL int yylex()
#define RETURN theParseLog.str(""); return

static int theNestCount=0;

%}

%x transform rule comment linecomment string litcode

PASS_CHARS [.<>,*/()[\]+-]

%%
<INITIAL>{
  "main"           RETURN MAIN;
  "transform"      RETURN TRANSFORM;
  "through"        RETURN THROUGH;
  "testcase"       RETURN TESTCASE;
  "{"              yy_push_state(transform); RETURN '{';
  "%{"             yy_push_state(litcode); theParseLog.str("");
}

<litcode>{
  [^%]*            /*nothing*/
  [%][^}]          /*nothing*/
  "%}"             {
      yy_pop_state();
      recordLitCode();
  }
}

<transform>{
  "where"          RETURN WHERE;
  "priority"       RETURN PRIORITY;
  "primary"        RETURN PRIMARY;
  "secondary"      RETURN SECONDARY;
  "rotatable"      RETURN ROTATABLE;
  "recursive"      RETURN RECURSIVE;
  "{"              yy_push_state(rule); theNestCount=1; RETURN *yytext;
  "}"              yy_pop_state();      RETURN *yytext;
}

<INITIAL,transform>{
  "to"              RETURN TO;
  "from"            RETURN FROM;
  "<="              RETURN LE;
  ">="              RETURN GE;
  [0-9]+[.][0-9]+   RETURN FLOAT;
  [0-9]+            RETURN INTEGER;
  [a-z_][a-z0-9_]*  RETURN IDENT;
  {PASS_CHARS}      RETURN yytext[0];
  [/][*]            yy_push_state(comment);
  [/][/]            yy_push_state(linecomment);
  ^[ \t]*[#]        yy_push_state(linecomment);
}

<rule>{
  [/][*]           yy_push_state(comment);
  [/][/]           yy_push_state(linecomment);
  ^[ \t]*[#]       yy_push_state(linecomment);
  "{"              ++theNestCount;
  ["]              yy_push_state(string);
  "}"              { 
                      if(--theNestCount==0){
                        yy_pop_state();
                        pblval.str=circularStringCache(theParseLog.str().c_str());
                        RETURN RULEBODY;
                      }
                   }
  [^*/{}"]+        /*nothing*/
  .                /*nothing*/
}

<comment>{
  "*/"             yy_pop_state();
  [^*]+            /*nothing*/
  .                /*nothing*/
}

<linecomment>{
  [\n]           yy_pop_state();
  [^\n]+         /*nothing*/
}

<string>{
  ["]            yy_pop_state();
  [^"]           /*nothing*/
  [\\]["]        /*nothing*/
}

<*>{
  [ \t\r\n]      /* whitespace */;
  .              JASSERT(false)(yytext)(yylineno).Text("Unhandled input");
}

%%


