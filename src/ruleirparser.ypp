%{
#include <stdio.h>
#include <map>
#include "ruleir.h"
#include "jconvert.h"
#include "formula.h"

using namespace hecura;

extern int ruleirlineno;
extern std::string ruleirfilename;

extern int yylex (void);
static int yyerror(const RIRBlockPtr&, const char* msg){ 
  JASSERT(false)
    (ruleirfilename)
    (ruleirlineno)
    (msg)
    .Text("parse error"); 
  return 0;
}

static jalib::JRefPool theRefPool;
#define REFALLOC(args...) (theRefPool.add(new args))

static void clearParserCaches(){
  theRefPool.clear();
}

%}

%union {
  const char* str;
  hecura::RIRExpr*  expr;
  hecura::RIRStmt*  stmt;
  hecura::RIRBlock* block;
}

%defines
%locations
%expect 2
%name-prefix="ruleir"
%start Start
%parse-param { hecura::RIRBlockPtr& ret };

%type <str> TOK_OP TOK_LIT TOK_IDENT TOK_RAW
%type <expr> Op
%type <expr> Lit
%type <expr> Ident
%type <expr> ExprElement Expr RootExpr
%type <expr> Call Paren
%type <expr> Args OptArgs

%type <stmt> Stmt IfStmt LoopStmt BlockStmt RawStmt ReturnStmt IntlzrStmt
%type <block> Block

%left TOK_OP TOK_LIT TOK_IDENT TOK_IF TOK_THEN TOK_ELSE TOK_FOR TOK_WHILE TOK_DO TOK_RETURN TOK_BREAK TOK_CONTINUE TOK_RAW

%%

Start: Block {
  ret=$1;
}

Block: Block Stmt {($$=$1)->addStmt($2);}
     | Nil        {$$=REFALLOC(RIRBlock());};

Stmt: RootExpr ';' {($$=REFALLOC(RIRBasicStmt()))->addExpr($1);}
    | Nil      ';' {($$=REFALLOC(RIRBasicStmt()));}
    | IfStmt     {$$=$1;}
    | LoopStmt   {$$=$1;}
    | BlockStmt  {$$=$1;}
    | ReturnStmt {$$=$1;}
    | IntlzrStmt {$$=$1;}
    | RawStmt    {$$=$1;};

IfStmt: TOK_IF '(' Expr ')' Stmt                {
  $$=REFALLOC(RIRIfStmt($5));
  $$->addExpr($3);
};

IfStmt: TOK_IF '(' Expr ')' Stmt TOK_ELSE  Stmt {
  $$=REFALLOC(RIRIfStmt($5, $7));
  $$->addExpr($3);
};

LoopStmt: TOK_FOR '(' Expr ';' Expr ';' Expr ')' Stmt {
  $$=REFALLOC(RIRLoopStmt($9));
  $$->addExpr($3);
  $$->addExpr($5);
  $$->addExpr($7);
};

LoopStmt: TOK_WHILE '(' Expr ')' Stmt {
  $$=REFALLOC(RIRLoopStmt($5));
  $$->addExpr(REFALLOC(RIRNilExpr()));
  $$->addExpr($3);
  $$->addExpr(REFALLOC(RIRNilExpr()));
};

LoopStmt: TOK_DO Stmt TOK_WHILE '(' Expr ')' ';'{
  $$=REFALLOC(RIRLoopStmt($2));
  UNIMPLEMENTED();
};

IntlzrStmt: RootExpr '{' RootExpr '}' ';' {
  $$=REFALLOC(RIRBasicStmt());
  $$->addExpr($1);
  $$->addExpr(REFALLOC(RIROpExpr("{")));
  $$->addExpr($3);
  $$->addExpr(REFALLOC(RIROpExpr("}")));
};

BlockStmt: '{' Block '}' {
  $$=REFALLOC(RIRBlockStmt($2));
};

ReturnStmt: TOK_RETURN Expr ';' {
  $$=REFALLOC(RIRReturnStmt());
  $$->addExpr(REFALLOC(RIRKeywordExpr("return")));
  $$->addExpr($2);
};

RawStmt: TOK_RAW {
  $$=REFALLOC(RIRRawStmt($1));
};

Expr: Expr ExprElement     {($$=$1)->addSubExpr($2);}
    | ExprElement          {($$=REFALLOC(RIRChainExpr()))->addSubExpr($1);};

RootExpr: RootExpr ExprElement {($$=$1)->addSubExpr($2);}
        | RootExpr ','         {($$=$1)->addSubExpr(REFALLOC(RIROpExpr(",")));}
        | ExprElement          {($$=REFALLOC(RIRChainExpr()))->addSubExpr($1);};

ExprElement: Op    {$$=$1;}
           | Lit   {$$=$1;}
           | Ident {$$=$1;}
           | Call  {$$=$1;}
           | Paren {$$=$1;};

Call: Ident '(' OptArgs ')'  { 
  $$=REFALLOC(RIRCallExpr()); 
  $$->addSubExpr($1);
  $$->addSubExpr($3);
};

Paren: '(' Expr ')' {
  $$=REFALLOC(RIRChainExpr());
  $$->addSubExpr(REFALLOC(RIROpExpr("(")));
  $$->addSubExpr($2);
  $$->addSubExpr(REFALLOC(RIROpExpr(")")));
};

Args: Expr          { ($$=REFALLOC(RIRArgsExpr()))->addSubExpr($1); }
    | Args ',' Expr { ($$=$1)->addSubExpr($3); };

OptArgs: Nil   {$$=REFALLOC(RIRArgsExpr());}
       | Args  {$$=$1;};

Op:    TOK_OP    {$$=REFALLOC(RIROpExpr($1));};
Lit:   TOK_LIT   {$$=REFALLOC(RIRLitExpr($1));};
Ident: TOK_IDENT {$$=REFALLOC(RIRIdentExpr($1));};

Nil:;

%%

void _ruleirlexer_scan_string( const std::string& str);

RIRBlockPtr parseRuleBody(const std::string& str){
  JTRACE("Parsing rule body")(str);
  _ruleirlexer_scan_string(str);
  RIRBlockPtr ret;
  ruleirparse(ret);
  return ret;
}


