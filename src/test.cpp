/***************************************************************************
 *   Copyright (C) 2008 by Jason Ansel                                     *
 *   jansel@csail.mit.edu                                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "matrixio.h"

// Generated by hecura PetaBricks Compiler (pbc) v0.10
#include "matrix.h"
using namespace hecura;

// Begin output for tranform MatrixAdd

// User rules
ValueT rule1(const ValueT& a, const ValueT& b){
  return a+b;
}

// Rule trampolines
void apply_rule1(MatrixRegion2D& AB, ConstMatrixRegion2D& B, ConstMatrixRegion2D& A, IndexT begin_r1_x, IndexT begin_r1_y, IndexT end_r1_x, IndexT end_r1_y){
  for(int _r1_x=begin_r1_x; _r1_x<end_r1_x; ++_r1_x){
    for(int _r1_y=begin_r1_y; _r1_y<end_r1_y; ++_r1_y){
      AB.cell(_r1_x, _r1_y) = rule1(A.cell(_r1_x, _r1_y), B.cell(_r1_x, _r1_y));
    }
  }
}

// Entry function
void MatrixAdd(MatrixRegion2D& AB, ConstMatrixRegion2D A, ConstMatrixRegion2D B){
  apply_rule1(AB, B, A, 0,0, AB.size(0), AB.size(1));
}

int main(int argc, const char** argv){
  MatrixRegion2D a = MatrixIO("A","r").read2D();
  MatrixRegion2D b = MatrixIO("B","r").read2D();
  MatrixRegion2D ab = MatrixIO("B","r").read2D();
  MatrixAdd(ab, a, b);
  MatrixIO("AB","w").write(ab);
  return 0;
}
