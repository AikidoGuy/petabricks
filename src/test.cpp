// Generated by hecura PetaBricks compiler (pbc) v0.10
#include "matrix.h"
#include "matrixio.h"
using namespace hecura;

// Begin output for transform Test1

// User rules
ElementT rule1(const ElementT& left, const ElementT& up){
  return left+up;
}
ElementT rule2(){
  return 1;
}

// Rule trampolines
void apply_rule1(const MatrixRegion2D& OUT, IndexT begin_r1_x, IndexT begin_r1_y, IndexT end_r1_x, IndexT end_r1_y){
  for(int _r1_x=begin_r1_x; _r1_x<end_r1_x; ++_r1_x){
    for(int _r1_y=begin_r1_y; _r1_y<end_r1_y; ++_r1_y){
      OUT.cell(_r1_x, _r1_y) = rule1(OUT.cell((_r1_x-1), _r1_y), OUT.cell(_r1_x, (_r1_y-1)));
    }
  }
}
void apply_rule2(const MatrixRegion2D& OUT, IndexT begin_r2_x, IndexT begin_r2_y, IndexT end_r2_x, IndexT end_r2_y){
  for(int _r2_x=begin_r2_x; _r2_x<end_r2_x; ++_r2_x){
    for(int _r2_y=begin_r2_y; _r2_y<end_r2_y; ++_r2_y){
      OUT.cell(_r2_x, _r2_y) = rule2();
    }
  }
}

// Test1 entry function
void Test1(const MatrixRegion2D& OUT, const ConstMatrixRegion2D& IN){
  // Extract matrix size parameters
  const IndexT w=IN.size(0);
  const IndexT h=IN.size(1);
  // Verify size of input/output
  JASSERT(w == IN.size(0))(w)(IN.size(0));
  JASSERT(h == IN.size(1))(h)(IN.size(1));
  JASSERT(w == OUT.size(0))(w)(OUT.size(0));
  JASSERT(h == OUT.size(1))(h)(OUT.size(1));
  // Run computation
  apply_rule2(OUT, 1,0, w,1);
  apply_rule2(OUT, 0,0, 1,h);
  apply_rule1(OUT, 1,1, w,h);
}

// Return style entry function
MatrixRegion2D Test1(const ConstMatrixRegion2D& IN){
  // Extract matrix size parameters
  const IndexT w=IN.size(0);
  const IndexT h=IN.size(1);
  // Allocate to matrix
  MatrixRegion2D OUT = MatrixRegion2D::allocate(w, h);
  // Call normal version
  Test1(OUT, IN);
  return OUT;
}

// Program main routine
int main(int argc, const char** argv){
  if(argc!=3){
    fprintf(stderr,"USAGE: Test1 IN OUT \n");
    return 1;
  }
  ConstMatrixRegion2D IN = hecura::MatrixIO(argv[1],"r").read<2>();
  // Extract matrix size parameters
  const IndexT w=IN.size(0);
  const IndexT h=IN.size(1);
  MatrixRegion2D OUT = MatrixRegion2D::allocate(w, h);
  Test1(OUT, IN);
  hecura::MatrixIO(argv[2],"w").write(OUT);
  return 0;
}