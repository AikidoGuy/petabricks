/***************************************************************************
 *   Copyright (C) 2008 by Jason Ansel                                     *
 *   jansel@csail.mit.edu                                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
// Generated by hecura PetaBricks compiler (pbc) v0.10
#include "matrix.h"
using namespace hecura;

// Begin output for transform Test1

// User rules
ElementT rule1(const ElementT& i, const ElementT& left, const ElementT& up){
  return i+left+up;
}
ElementT rule2(const ElementT& i){
  return i;
}
ElementT rule3(const ElementT& i){
  return i;
}

// Rule trampolines
void apply_rule1(const MatrixRegion2D& OUT, const ConstMatrixRegion2D& IN, IndexT begin_r1_x, IndexT begin_r1_y, IndexT end_r1_x, IndexT end_r1_y){
  for(int _r1_x=begin_r1_x; _r1_x<end_r1_x; ++_r1_x){
    for(int _r1_y=begin_r1_y; _r1_y<end_r1_y; ++_r1_y){
      OUT.cell(_r1_x, _r1_y) = rule1(IN.cell(_r1_x, _r1_y), OUT.cell((_r1_x-1), _r1_y), OUT.cell(_r1_x, (_r1_y-1)));
    }
  }
}
void apply_rule2(const MatrixRegion2D& OUT, const ConstMatrixRegion2D& IN, IndexT begin_r2_x, IndexT begin_r2_y, IndexT end_r2_x, IndexT end_r2_y){
  for(int _r2_x=begin_r2_x; _r2_x<end_r2_x; ++_r2_x){
    for(int _r2_y=begin_r2_y; _r2_y<end_r2_y; ++_r2_y){
      OUT.cell(0, _r2_y) = rule2(IN.cell(0, _r2_y));
    }
  }
}
void apply_rule3(const MatrixRegion2D& OUT, const ConstMatrixRegion2D& IN, IndexT begin_r3_x, IndexT begin_r3_y, IndexT end_r3_x, IndexT end_r3_y){
  for(int _r3_x=begin_r3_x; _r3_x<end_r3_x; ++_r3_x){
    for(int _r3_y=begin_r3_y; _r3_y<end_r3_y; ++_r3_y){
      OUT.cell(_r3_x, 0) = rule3(IN.cell(_r3_x, 0));
    }
  }
}

// Entry function
void Test1(const MatrixRegion2D& OUT, const ConstMatrixRegion2D& IN){
  // Extract matrix size parameters
  const IndexT w=IN.size(0);
  const IndexT h=IN.size(1);
  // Verify size of input/output
  JASSERT(w == IN.size(0))(w)(IN.size(0));
  JASSERT(h == IN.size(1))(h)(IN.size(1));
  JASSERT(w == OUT.size(0))(w)(OUT.size(0));
  JASSERT(h == OUT.size(1))(h)(OUT.size(1));
  // Run computation
  apply_rule3(OUT, IN, 1,0, w,1);
  apply_rule2(OUT, IN, 0,1, 1,h);
  apply_rule3(OUT, IN, 0,0, 1,1);
  apply_rule1(OUT, IN, 1,1, w,h);
}

// Return style entry function
MatrixRegion2D Test1(const ConstMatrixRegion2D& IN){
  // Extract matrix size parameters
  const IndexT w=IN.size(0);
  const IndexT h=IN.size(1);
  // Allocate to matrix
  MatrixRegion2D OUT = MatrixRegion2D::allocate(w, h);
  // Call normal version
  Test1(OUT, IN);
  return OUT;
}


#include "matrixio.h"
int main(int argc, const char** argv){
  MatrixRegion2D in  = MatrixIO("A","r").read2D();
  MatrixIO().write(Test1(in));
  return 0;
}
